{% extends "layout.html" %}

{% block content %}
<div class="container-fluid">
    <h1 class="mb-4">Gestionnaire de Bibliothèque Plex</h1>

    <!-- Zone des Filtres -->
    <div class="card bg-dark text-white mb-4">
        <div class="card-body">
            <h5 class="card-title">Filtres</h5>
            <div class="row g-3 align-items-end">
                <!-- Filtre Utilisateur -->
                <div class="col-md-3">
                    <label for="user-select" class="form-label">Utilisateur Plex</label>
                    <select id="user-select" class="form-select">
                        <option selected>Chargement...</option>
                        {# La liste des utilisateurs sera chargée ici par JS #}
                    </select>
                </div>
                <!-- Filtre Bibliothèque -->
                <div class="col-md-4">
                    <label for="library-select" class="form-label">Bibliothèque(s)</label>
                    <select id="library-select" class="form-select" multiple disabled>
                        {# La liste des bibliothèques sera chargée ici par JS #}
                    </select>
                </div>
                <!-- Autres filtres (statut, etc.) -->
                <div class="col-md-3">
                    <label for="status-filter" class="form-label">Statut</label>
                    <select id="status-filter" class="form-select">
                        <option value="all" selected>Tous</option>
                        <option value="unwatched">Non vus</option>
                        <option value="watched">Vus</option>
                    </select>
                </div>
                <!-- Bouton d'application -->
                <div class="col-md-2">
                    <button id="apply-filters-btn" class="btn btn-primary w-100">Appliquer</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Zone des Résultats -->
    <div id="plex-items-loader" class="text-center mt-5" style="display: none;">
        <div class="spinner-border text-primary" style="width: 3rem; height: 3rem;" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Chargement des médias...</p>
    </div>
    <div id="plex-items-container">
        <p class="text-center text-muted">Veuillez sélectionner un utilisateur et une bibliothèque pour afficher les médias.</p>
    </div>

</div>

<!-- Modale d'Information -->
<div class="modal fade" id="item-details-modal" tabindex="-1" aria-labelledby="itemDetailsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content bg-dark text-white">
            <div class="modal-header">
                <h5 class="modal-title" id="itemDetailsModalLabel">Détails du Média</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Le contenu sera injecté ici par JavaScript -->
                <div class="text-center" id="modal-loader">
                    <div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div>
                </div>
                <div id="modal-content-container" class="d-none">
                    <!-- Structure du contenu détaillé -->
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    const userSelect = document.getElementById('user-select');
    const librarySelect = document.getElementById('library-select');
    const applyBtn = document.getElementById('apply-filters-btn');
    const loader = document.getElementById('plex-items-loader');
    const itemsContainer = document.getElementById('plex-items-container');

    const LAST_USER_KEY = 'mms_last_plex_user_id';
    const LIBS_CACHE_KEY_PREFIX = 'mms_plex_libs_for_user_'; // Préfixe pour les clés de cache

    // --- FONCTION UTILITAIRE pour peupler la liste des bibliothèques ---
    function populateLibraries(libraries) {
        librarySelect.innerHTML = '';
        if (libraries && libraries.length > 0) {
            libraries.forEach(lib => {
                const option = new Option(lib.text, lib.id);
                librarySelect.add(option);
            });
            librarySelect.disabled = false;
        } else {
            librarySelect.innerHTML = '<option selected disabled>Aucune bibliothèque trouvée</option>'; // Modifié pour être disabled
            librarySelect.disabled = true;
        }
    }

    // --- 1. Charger les utilisateurs au démarrage ---
    fetch("{{ url_for('plex_editor.get_plex_users') }}")
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(users => {
            userSelect.innerHTML = '<option value="" selected disabled>Choisir un utilisateur...</option>';
            if (users && users.length > 0) {
                users.forEach(user => {
                    const option = new Option(user.text, user.id);
                    userSelect.add(option);
                });
            } else {
                 userSelect.innerHTML = '<option selected>Aucun utilisateur trouvé</option>';
            }

            // --- NOUVELLE LOGIQUE : Recharger le dernier utilisateur ---
            const lastUserId = localStorage.getItem(LAST_USER_KEY);
            if (lastUserId) {
                // Vérifier si l'option existe avant de la sélectionner
                if (Array.from(userSelect.options).some(opt => opt.value === lastUserId)) {
                    userSelect.value = lastUserId;
                    // Déclenche manuellement l'événement 'change' pour charger les bibliothèques
                    userSelect.dispatchEvent(new Event('change'));
                } else {
                    localStorage.removeItem(LAST_USER_KEY); // Clé invalide, on la supprime
                }
            }
        })
        .catch(error => {
            console.error("Erreur lors du chargement des utilisateurs:", error);
            userSelect.innerHTML = '<option selected>Erreur de chargement des utilisateurs</option>';
            itemsContainer.innerHTML = `<p class="text-danger text-center">Erreur chargement utilisateurs: ${error.message}</p>`;
        });

    // --- 2. Charger les bibliothèques ET SAUVEGARDER le choix ---
    userSelect.addEventListener('change', function () {
        const userId = this.value;

        // --- NOUVELLE LOGIQUE : Sauvegarder le choix de l'utilisateur ---
        if (userId) {
            localStorage.setItem(LAST_USER_KEY, userId);
        } else {
            // Si l'utilisateur sélectionne "Choisir un utilisateur...", on pourrait vouloir effacer la clé
            localStorage.removeItem(LAST_USER_KEY);
        }

        // Réinitialiser l'affichage des items et le sélecteur de bibliothèques
        itemsContainer.innerHTML = '<p class="text-center text-muted">Veuillez sélectionner une ou plusieurs bibliothèques et appliquer les filtres.</p>';
        librarySelect.innerHTML = '<option selected disabled>Chargement...</option>';
        librarySelect.disabled = true;

        if (!userId) { // Si "Choisir un utilisateur..." est sélectionné
            populateLibraries([]); // Vide et désactive le sélecteur de bibliothèques
            return;
        }

        // --- NOUVELLE LOGIQUE DE CACHE ---
        const cacheKey = LIBS_CACHE_KEY_PREFIX + userId;
        const cachedLibs = localStorage.getItem(cacheKey);

        if (cachedLibs) {
            console.log(`Bibliothèques pour l'utilisateur ${userId} chargées depuis le cache.`);
            populateLibraries(JSON.parse(cachedLibs));
        } else {
            console.log(`Cache vide pour l'utilisateur ${userId}, appel de l'API pour les bibliothèques.`);
            // librarySelect est déjà en mode "Chargement..." et disabled

            const libraryUrl = "{{ url_for('plex_editor.get_user_libraries', user_id='USER_ID_PLACEHOLDER') }}".replace('USER_ID_PLACEHOLDER', userId);

            fetch(libraryUrl)
                .then(response => {
                    if (!response.ok) {
                        // Si l'API renvoie une erreur JSON, essayer de la parser
                        return response.json().then(errData => {
                            throw new Error(`HTTP error! status: ${response.status}, message: ${errData.error || 'Unknown API error'}`);
                        }).catch(() => {
                            // Fallback si le corps n'est pas JSON ou si response.json() échoue
                            throw new Error(`HTTP error! status: ${response.status}`);
                        });
                    }
                    return response.json();
                })
                .then(libraries => {
                    localStorage.setItem(cacheKey, JSON.stringify(libraries));
                    populateLibraries(libraries);
                })
                .catch(error => {
                    console.error("Erreur lors du chargement des bibliothèques:", error);
                    librarySelect.innerHTML = '<option selected disabled>Erreur de chargement</option>';
                    librarySelect.disabled = true;
                    // Afficher l'erreur aussi dans la zone des items peut être une bonne idée
                    itemsContainer.innerHTML = `<p class="text-danger text-center">Erreur lors du chargement des bibliothèques: ${error.message}</p>`;
                });
        }
    });

    // --- 3. Logique du bouton "Appliquer" ---
    applyBtn.addEventListener('click', function() {
        const userId = userSelect.value;
        const selectedLibraries = Array.from(librarySelect.selectedOptions).map(opt => opt.value);
        const statusFilter = document.getElementById('status-filter').value;

        if (!userId || selectedLibraries.length === 0) {
            itemsContainer.innerHTML = '<p class="text-center text-warning">Veuillez sélectionner un utilisateur et au moins une bibliothèque.</p>';
            return;
        }

        loader.style.display = 'block';
        itemsContainer.innerHTML = '';

        fetch("{{ url_for('plex_editor.get_media_items') }}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', },
            body: JSON.stringify({
                userId: userId,
                libraryKeys: selectedLibraries,
                statusFilter: statusFilter
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(errData => {
                    throw new Error(`Erreur HTTP: ${response.status} - ${errData.error || response.statusText}`);
                }).catch(() => {
                    throw new Error(`Erreur HTTP: ${response.status} - ${response.statusText}`);
                });
            }
            return response.text();
        })
        .then(html => {
            loader.style.display = 'none';
            itemsContainer.innerHTML = html;
        })
        .catch(error => {
            loader.style.display = 'none';
            itemsContainer.innerHTML = `<div class="alert alert-danger text-center">Erreur lors du chargement des médias: ${error.message}</div>`;
            console.error('Erreur lors du chargement des médias:', error);
        });
    });

    // --- Gestionnaire d'événements pour les actions sur les items ---
    itemsContainer.addEventListener('click', function(event) {
        const deleteButton = event.target.closest('.delete-item-btn');
        const toggleButton = event.target.closest('.toggle-watched-btn');
        const titleLink = event.target.closest('.item-title-link');

        if (deleteButton) {
            event.preventDefault();
            const ratingKey = deleteButton.dataset.ratingKey;
            const itemTitle = deleteButton.dataset.itemTitle || 'cet élément';

            if (confirm(`Êtes-vous sûr de vouloir supprimer définitivement "${itemTitle}" de Plex ?`)) {
                deleteButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
                deleteButton.disabled = true;
                const finalUrl = `{{ url_for('plex_editor.delete_media_item_api', rating_key=0) }}`.replace('0', ratingKey);


                fetch(finalUrl, { method: 'DELETE' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        deleteButton.closest('tr').remove();
                        console.log(data.message);
                        if (itemsContainer.querySelectorAll('tbody tr').length === 0) {
                            itemsContainer.innerHTML = '<p class="text-center text-muted">Aucun média trouvé pour les filtres sélectionnés.</p>';
                        }
                    } else { throw new Error(data.message || 'Erreur inconnue lors de la suppression.'); }
                })
                .catch(error => {
                    alert(`Erreur lors de la suppression : ${error.message}`);
                    console.error('Erreur de suppression:', error);
                    deleteButton.innerHTML = '<i class="bi bi-trash-fill"></i>';
                    deleteButton.disabled = false;
                });
            }
        } else if (toggleButton) {
            event.preventDefault();
            const ratingKey = toggleButton.dataset.ratingKey;
            const currentUserId = userSelect.value;

            if (!currentUserId) {
                alert("Veuillez d'abord sélectionner un utilisateur.");
                return;
            }

            toggleButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
            toggleButton.disabled = true;
            const toggleUrl = `{{ url_for('plex_editor.toggle_watched_status_api', rating_key=0) }}`.replace('0', ratingKey);

            fetch(toggleUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', },
                body: JSON.stringify({ userId: currentUserId })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const statusCell = document.querySelector(`.media-status-cell[data-rating-key="${ratingKey}"]`);
                    if (statusCell) {
                        if (data.is_watched) { // Utiliser data.is_watched qui est un booléen
                            statusCell.innerHTML = `<span class="badge bg-success">Vu</span>`;
                        } else {
                            statusCell.innerHTML = `<span class="badge bg-warning text-dark">Non Vu</span>`;
                        }
                    }
                } else { throw new Error(data.message || 'Erreur inconnue lors du changement de statut.'); }
            })
            .catch(error => {
                alert(`Erreur lors du changement de statut : ${error.message}`);
                console.error('Erreur de bascule du statut vu/non vu:', error);
            })
            .finally(() => {
                // Rétablir l'icône correcte, peut-être en fonction du nouvel état si nécessaire
                const statusCell = document.querySelector(`.media-status-cell[data-rating-key="${ratingKey}"]`);
                // Pour l'instant, on remet l'icône 'eye' par défaut. Une logique plus fine pourrait être ajoutée.
                toggleButton.innerHTML = '<i class="bi bi-eye-fill"></i>';
                toggleButton.disabled = false;
            });
        } else if (titleLink) {
            event.preventDefault(); // Empêche le lien de remonter en haut de la page
            const ratingKey = titleLink.dataset.ratingKey;

            const modalLoader = document.getElementById('modal-loader');
            const modalContentContainer = document.getElementById('modal-content-container'); // Corrigé ici
            const modalTitle = document.getElementById('itemDetailsModalLabel');

            // Réinitialise et affiche le loader
            modalTitle.textContent = 'Chargement des détails...';
            modalLoader.style.display = 'block';
            modalContentContainer.innerHTML = ''; // Vide le contenu précédent
            modalContentContainer.classList.add('d-none');

            // Fait l'appel API
            // Assurez-vous que `plex_editor.get_media_details_for_modal` est le nom correct de la fonction de la route
            fetch(`{{ url_for('plex_editor.get_media_details_for_modal', rating_key=0) }}`.replace('0', ratingKey))
                .then(response => {
                    if (!response.ok) {
                        // Essayer de parser le JSON d'erreur si possible
                        return response.json().then(errData => {
                            throw new Error(errData.error || `Erreur HTTP ${response.status}`);
                        }).catch(() => {
                            // Fallback si le corps n'est pas JSON ou si response.json() échoue
                            throw new Error(`Erreur HTTP ${response.status}`);
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) throw new Error(data.error); // Si l'API retourne une erreur dans un JSON valide

                    // Remplit la modale avec les nouvelles données
                    modalTitle.textContent = data.title || 'Détails du Média';
                    let posterHtml = data.poster_url ? `<img src="${data.poster_url}" class="img-fluid rounded mb-3">` : '<p class_text-muted">Aucune affiche disponible.</p>';

                    modalContentContainer.innerHTML = `
                        <div class="row">
                            <div class="col-md-4">
                                ${posterHtml}
                            </div>
                            <div class="col-md-8">
                                <h4>${data.title || 'Titre inconnu'} ${data.year ? `(${data.year})` : ''}</h4>
                                <p class="fst-italic text-muted">${data.tagline || ''}</p>
                                <p>${data.summary || 'Aucun résumé.'}</p>
                                <p><strong>Genres:</strong> ${data.genres && data.genres.length > 0 ? data.genres.join(', ') : 'Non spécifiés'}</p>
                                <p><strong>Note:</strong> ${data.rating ? `${data.rating} / 10` : 'Non noté'}</p>
                            </div>
                        </div>
                    `;

                    // Affiche le contenu et cache le loader
                    modalLoader.style.display = 'none';
                    modalContentContainer.classList.remove('d-none');
                })
                .catch(error => {
                    modalLoader.style.display = 'none';
                    modalTitle.textContent = 'Erreur';
                    modalContentContainer.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
                    modalContentContainer.classList.remove('d-none');
                    console.error("Erreur lors du chargement des détails du média:", error);
                });
        }
    });
});
</script>
{% endblock %}