{% extends "layout.html" %}

{% block content %}
<div class="container-fluid">
    <h1 class="mb-4">Gestionnaire de Bibliothèque Plex</h1>

    <!-- Zone des Filtres -->
    <div class="card bg-dark text-white mb-4">
        <div class="card-body">
            <h5 class="card-title">Filtres</h5>
            <div class="row g-3 align-items-end">
                <!-- Filtre Utilisateur -->
                <div class="col-md-3">
                    <label for="user-select" class="form-label">Utilisateur Plex</label>
                    <select id="user-select" class="form-select">
                        <option selected>Chargement...</option>
                        {# La liste des utilisateurs sera chargée ici par JS #}
                    </select>
                </div>
                <!-- Filtre Bibliothèque -->
                <div class="col-md-4">
                    <label for="library-select" class="form-label">Bibliothèque(s)</label>
                    <select id="library-select" class="form-select" multiple disabled>
                        {# La liste des bibliothèques sera chargée ici par JS #}
                    </select>
                </div>
                <!-- Autres filtres (statut, etc.) -->
                <div class="col-md-3">
                    <label for="status-filter" class="form-label">Statut</label>
                    <select id="status-filter" class="form-select">
                        <option value="all" selected>Tous les statuts</option>
                        <option value="unwatched">Non commencé</option>
                        <option value="in_progress">En cours</option>
                        <option value="watched">Terminé / Vu</option>
                    </select>
                </div>
                <!-- Bouton d'application -->
                <div class="col-md-2">
                    <button id="apply-filters-btn" class="btn btn-primary w-100">Appliquer</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Zone des Résultats -->
    <div id="plex-items-loader" class="text-center mt-5" style="display: none;">
        <div class="spinner-border text-primary" style="width: 3rem; height: 3rem;" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Chargement des médias...</p>
    </div>
    <div id="plex-items-container">
        <p class="text-center text-muted">Veuillez sélectionner un utilisateur et une bibliothèque pour afficher les médias.</p>
    </div>

</div>

<!-- Modale d'Information -->
<div class="modal fade" id="item-details-modal" tabindex="-1" aria-labelledby="itemDetailsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content bg-dark text-white">
            <div class="modal-header">
                <h5 class="modal-title" id="itemDetailsModalLabel">Détails du Média</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Le contenu sera injecté ici par JavaScript -->
                <div class="text-center" id="modal-loader">
                    <div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div>
                </div>
                <div id="modal-content-container" class="d-none">
                    <!-- Structure du contenu détaillé -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modale d'Archivage de Film -->
<div class="modal fade" id="archiveMovieModal" tabindex="-1" aria-labelledby="archiveMovieModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content bg-dark text-white">
            <div class="modal-header">
                <h5 class="modal-title" id="archiveMovieModalLabel">Archiver le film : <span id="archiveMovieTitle"></span></h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Veuillez confirmer les options d'archivage pour ce film :</p>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="" id="archiveMovieDeleteFiles">
                    <label class="form-check-label" for="archiveMovieDeleteFiles">
                        Supprimer les fichiers du disque
                    </label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="" id="archiveMovieUnmonitor">
                    <label class="form-check-label" for="archiveMovieUnmonitor">
                        Ne plus monitorer dans Radarr
                    </label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="" id="archiveMovieAddTag">
                    <label class="form-check-label" for="archiveMovieAddTag">
                        Ajouter le tag "vu" dans Radarr
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                <button type="button" class="btn btn-primary" id="confirmArchiveMovieBtn">Confirmer l'archivage</button>
            </div>
        </div>
    </div>
</div>

<!-- Modale d'Archivage de Série -->
<div class="modal fade" id="archiveShowModal" tabindex="-1" aria-labelledby="archiveShowModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content bg-dark text-white">
            <div class="modal-header">
                <h5 class="modal-title" id="archiveShowModalLabel">Archiver la série : <span id="archiveShowTitle"></span></h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Informations sur la série :</p>
                <ul>
                    <li>Total épisodes : <span id="archiveShowTotalCount">N/A</span></li>
                    <li>Épisodes vus : <span id="archiveShowViewedCount">N/A</span></li>
                </ul>
                <p>Veuillez confirmer les options d'archivage pour cette série :</p>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="" id="archiveShowDeleteFiles">
                    <label class="form-check-label" for="archiveShowDeleteFiles">
                        Supprimer les fichiers des épisodes du disque
                    </label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="" id="archiveShowUnmonitor">
                    <label class="form-check-label" for="archiveShowUnmonitor">
                        Ne plus monitorer dans Sonarr (série et saisons)
                    </label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="" id="archiveShowAddTag">
                    <label class="form-check-label" for="archiveShowAddTag">
                        Ajouter les tags "vu" & "vu-complet" dans Sonarr
                    </label>
                </div>
                 <p class="mt-3"><small>Note : Pour une gestion plus fine des saisons (monitoring individuel, suppression partielle), utilisez l'option "Gérer les saisons" directement sur l'élément.</small></p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                <button type="button" class="btn btn-primary" id="confirmArchiveShowBtn">Confirmer l'archivage</button>
            </div>
        </div>
    </div>
</div>

<!-- Modale de Rejet de Série -->
<div class="modal fade" id="rejectShowModal" tabindex="-1" aria-labelledby="rejectShowModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content bg-dark text-white">
            <div class="modal-header">
                <h5 class="modal-title" id="rejectShowModalLabel">Rejeter la série : <span id="rejectShowTitle"></span></h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Êtes-vous sûr de vouloir rejeter cette série ?</p>
                <p>Cette action va :</p>
                <ul>
                    <li>Passer la série en "non monitorée" dans Sonarr.</li>
                    <li>Ajouter un tag "rejeté" dans Sonarr.</li>
                    <li>Supprimer tous les fichiers associés à cette série du disque.</li>
                </ul>
                <p class="text-danger fw-bold">Cette action est irréversible concernant les fichiers.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                <button type="button" class="btn btn-danger" id="confirmRejectShowBtn">Oui, rejeter et supprimer</button>
            </div>
        </div>
    </div>
</div>

<!-- Modale de Gestion de Série -->
<div class="modal fade" id="series-management-modal" tabindex="-1" aria-labelledby="seriesManagementModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable"> {# modal-lg pour plus d'espace, modal-dialog-scrollable pour contenu long #}
        <div class="modal-content bg-dark text-white">
            <div class="modal-header">
                <h5 class="modal-title" id="seriesManagementModalLabel">Gestion de la Série : <span id="seriesManagementModalTitle"></span></h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                {# Le contenu sera injecté ici par JavaScript depuis _series_management_modal_content.html #}
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Chargement...</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fermer</button>
                {# Des boutons d'action pourraient être ajoutés ici plus tard si nécessaire #}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    const userSelect = document.getElementById('user-select');
    const librarySelect = document.getElementById('library-select');
    const applyBtn = document.getElementById('apply-filters-btn');
    const loader = document.getElementById('plex-items-loader');
    const itemsContainer = document.getElementById('plex-items-container');

    const LAST_USER_KEY = 'mms_last_plex_user_id';
    const LIBS_CACHE_KEY_PREFIX = 'mms_plex_libs_for_user_'; // Préfixe pour les clés de cache

    // --- FONCTION UTILITAIRE pour peupler la liste des bibliothèques ---
    function populateLibraries(libraries) {
        librarySelect.innerHTML = '';
        if (libraries && libraries.length > 0) {
            libraries.forEach(lib => {
                const option = new Option(lib.text, lib.id);
                librarySelect.add(option);
            });
            librarySelect.disabled = false;
        } else {
            librarySelect.innerHTML = '<option selected disabled>Aucune bibliothèque trouvée</option>'; // Modifié pour être disabled
            librarySelect.disabled = true;
        }
    }

    // --- 1. Charger les utilisateurs au démarrage ---
    fetch("{{ url_for('plex_editor.get_plex_users') }}")
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(users => {
            userSelect.innerHTML = '<option value="" selected disabled>Choisir un utilisateur...</option>';
            if (users && users.length > 0) {
                users.forEach(user => {
                    const option = new Option(user.text, user.id);
                    userSelect.add(option);
                });
            } else {
                 userSelect.innerHTML = '<option selected>Aucun utilisateur trouvé</option>';
            }

            // --- NOUVELLE LOGIQUE : Recharger le dernier utilisateur ---
            const lastUserId = localStorage.getItem(LAST_USER_KEY);
            if (lastUserId) {
                // Vérifier si l'option existe avant de la sélectionner
                if (Array.from(userSelect.options).some(opt => opt.value === lastUserId)) {
                    userSelect.value = lastUserId;
                    // Déclenche manuellement l'événement 'change' pour charger les bibliothèques
                    userSelect.dispatchEvent(new Event('change'));
                } else {
                    localStorage.removeItem(LAST_USER_KEY); // Clé invalide, on la supprime
                }
            }
        })
        .catch(error => {
            console.error("Erreur lors du chargement des utilisateurs:", error);
            userSelect.innerHTML = '<option selected>Erreur de chargement des utilisateurs</option>';
            itemsContainer.innerHTML = `<p class="text-danger text-center">Erreur chargement utilisateurs: ${error.message}</p>`;
        });

    // --- 2. Charger les bibliothèques ET SAUVEGARDER le choix ---
    userSelect.addEventListener('change', function () {
        const userId = this.value;

        // --- NOUVELLE LOGIQUE : Sauvegarder le choix de l'utilisateur ---
        if (userId) {
            localStorage.setItem(LAST_USER_KEY, userId);
        } else {
            // Si l'utilisateur sélectionne "Choisir un utilisateur...", on pourrait vouloir effacer la clé
            localStorage.removeItem(LAST_USER_KEY);
        }

        // Réinitialiser l'affichage des items et le sélecteur de bibliothèques
        itemsContainer.innerHTML = '<p class="text-center text-muted">Veuillez sélectionner une ou plusieurs bibliothèques et appliquer les filtres.</p>';
        librarySelect.innerHTML = '<option selected disabled>Chargement...</option>';
        librarySelect.disabled = true;

        if (!userId) { // Si "Choisir un utilisateur..." est sélectionné
            populateLibraries([]); // Vide et désactive le sélecteur de bibliothèques
            return;
        }

        // --- NOUVELLE LOGIQUE DE CACHE ---
        const cacheKey = LIBS_CACHE_KEY_PREFIX + userId;
        const cachedLibs = localStorage.getItem(cacheKey);

        if (cachedLibs) {
            console.log(`Bibliothèques pour l'utilisateur ${userId} chargées depuis le cache.`);
            populateLibraries(JSON.parse(cachedLibs));
        } else {
            console.log(`Cache vide pour l'utilisateur ${userId}, appel de l'API pour les bibliothèques.`);
            // librarySelect est déjà en mode "Chargement..." et disabled

            const libraryUrl = "{{ url_for('plex_editor.get_user_libraries', user_id='USER_ID_PLACEHOLDER') }}".replace('USER_ID_PLACEHOLDER', userId);

            fetch(libraryUrl)
                .then(response => {
                    if (!response.ok) {
                        // Si l'API renvoie une erreur JSON, essayer de la parser
                        return response.json().then(errData => {
                            throw new Error(`HTTP error! status: ${response.status}, message: ${errData.error || 'Unknown API error'}`);
                        }).catch(() => {
                            // Fallback si le corps n'est pas JSON ou si response.json() échoue
                            throw new Error(`HTTP error! status: ${response.status}`);
                        });
                    }
                    return response.json();
                })
                .then(libraries => {
                    localStorage.setItem(cacheKey, JSON.stringify(libraries));
                    populateLibraries(libraries);
                })
                .catch(error => {
                    console.error("Erreur lors du chargement des bibliothèques:", error);
                    librarySelect.innerHTML = '<option selected disabled>Erreur de chargement</option>';
                    librarySelect.disabled = true;
                    // Afficher l'erreur aussi dans la zone des items peut être une bonne idée
                    itemsContainer.innerHTML = `<p class="text-danger text-center">Erreur lors du chargement des bibliothèques: ${error.message}</p>`;
                });
        }
    });

    // --- 3. Logique du bouton "Appliquer" ---
    applyBtn.addEventListener('click', function() {
        const userId = userSelect.value;
        const selectedLibraries = Array.from(librarySelect.selectedOptions).map(opt => opt.value);
        const statusFilter = document.getElementById('status-filter').value;

        if (!userId || selectedLibraries.length === 0) {
            itemsContainer.innerHTML = '<p class="text-center text-warning">Veuillez sélectionner un utilisateur et au moins une bibliothèque.</p>';
            return;
        }

        loader.style.display = 'block';
        itemsContainer.innerHTML = '';

        fetch("{{ url_for('plex_editor.get_media_items') }}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', },
            body: JSON.stringify({
                userId: userId,
                libraryKeys: selectedLibraries,
                statusFilter: statusFilter
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(errData => {
                    throw new Error(`Erreur HTTP: ${response.status} - ${errData.error || response.statusText}`);
                }).catch(() => {
                    throw new Error(`Erreur HTTP: ${response.status} - ${response.statusText}`);
                });
            }
            return response.text();
        })
        .then(html => {
            loader.style.display = 'none';
            itemsContainer.innerHTML = html;
        })
        .catch(error => {
            loader.style.display = 'none';
            itemsContainer.innerHTML = `<div class="alert alert-danger text-center">Erreur lors du chargement des médias: ${error.message}</div>`;
            console.error('Erreur lors du chargement des médias:', error);
        });
    });

    // --- Gestionnaire d'événements pour les actions sur les items ---
    itemsContainer.addEventListener('click', function(event) {
        const deleteButton = event.target.closest('.delete-item-btn');
        const toggleButton = event.target.closest('.toggle-watched-btn');
        const titleLink = event.target.closest('.item-title-link');

        if (deleteButton) {
            event.preventDefault();
            const ratingKey = deleteButton.dataset.ratingKey;
            const itemTitle = deleteButton.dataset.itemTitle || 'cet élément';

            if (confirm(`Êtes-vous sûr de vouloir supprimer définitivement "${itemTitle}" de Plex ?`)) {
                deleteButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
                deleteButton.disabled = true;
                const finalUrl = `{{ url_for('plex_editor.delete_media_item_api', rating_key=0) }}`.replace('0', ratingKey);


                fetch(finalUrl, { method: 'DELETE' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        deleteButton.closest('tr').remove();
                        console.log(data.message);
                        if (itemsContainer.querySelectorAll('tbody tr').length === 0) {
                            itemsContainer.innerHTML = '<p class="text-center text-muted">Aucun média trouvé pour les filtres sélectionnés.</p>';
                        }
                    } else { throw new Error(data.message || 'Erreur inconnue lors de la suppression.'); }
                })
                .catch(error => {
                    alert(`Erreur lors de la suppression : ${error.message}`);
                    console.error('Erreur de suppression:', error);
                    deleteButton.innerHTML = '<i class="bi bi-trash-fill"></i>';
                    deleteButton.disabled = false;
                });
            }
        } else if (toggleButton) {
            event.preventDefault();
            const ratingKey = toggleButton.dataset.ratingKey;
            const currentUserId = userSelect.value;

            if (!currentUserId) {
                alert("Veuillez d'abord sélectionner un utilisateur.");
                return;
            }

            toggleButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
            toggleButton.disabled = true;
            const toggleUrl = `{{ url_for('plex_editor.toggle_watched_status_api', rating_key=0) }}`.replace('0', ratingKey);

            fetch(toggleUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', },
                body: JSON.stringify({ userId: currentUserId })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const statusCell = document.querySelector(`.media-status-cell[data-rating-key="${ratingKey}"]`);
                    if (statusCell) {
                        if (data.is_watched) { // Utiliser data.is_watched qui est un booléen
                            statusCell.innerHTML = `<span class="badge bg-success">Vu</span>`;
                        } else {
                            statusCell.innerHTML = `<span class="badge bg-warning text-dark">Non Vu</span>`;
                        }
                    }
                } else { throw new Error(data.message || 'Erreur inconnue lors du changement de statut.'); }
            })
            .catch(error => {
                alert(`Erreur lors du changement de statut : ${error.message}`);
                console.error('Erreur de bascule du statut vu/non vu:', error);
            })
            .finally(() => {
                // Rétablir l'icône correcte, peut-être en fonction du nouvel état si nécessaire
                const statusCell = document.querySelector(`.media-status-cell[data-rating-key="${ratingKey}"]`);
                // Pour l'instant, on remet l'icône 'eye' par défaut. Une logique plus fine pourrait être ajoutée.
                toggleButton.innerHTML = '<i class="bi bi-eye-fill"></i>';
                toggleButton.disabled = false;
            });
        } else if (titleLink) {
            event.preventDefault(); // Empêche le lien de remonter en haut de la page
            const ratingKey = titleLink.dataset.ratingKey;

            const modalLoader = document.getElementById('modal-loader');
            const modalContentContainer = document.getElementById('modal-content-container'); // Corrigé ici
            const modalTitle = document.getElementById('itemDetailsModalLabel');

            // Réinitialise et affiche le loader
            modalTitle.textContent = 'Chargement des détails...';
            modalLoader.style.display = 'block';
            modalContentContainer.innerHTML = ''; // Vide le contenu précédent
            modalContentContainer.classList.add('d-none');

            // Fait l'appel API
            fetch(`{{ url_for('plex_editor.get_media_details_for_modal', rating_key=0) }}`.replace('0', ratingKey))
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(errData => { throw new Error(errData.error || `Erreur HTTP ${response.status}`); })
                                     .catch(() => { throw new Error(`Erreur HTTP ${response.status}`); });
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) throw new Error(data.error);
                    modalTitle.textContent = data.title || 'Détails du Média';
                    let posterHtml = data.poster_url ? `<img src="${data.poster_url}" class="img-fluid rounded mb-3">` : '<p class="text-muted">Aucune affiche disponible.</p>';
                    modalContentContainer.innerHTML = `
                        <div class="row">
                            <div class="col-md-4">${posterHtml}</div>
                            <div class="col-md-8">
                                <h4>${data.title || 'Titre inconnu'} ${data.year ? `(${data.year})` : ''}</h4>
                                <p class="fst-italic text-muted">${data.tagline || ''}</p>
                                <p>${data.summary || 'Aucun résumé.'}</p>
                                <p><strong>Genres:</strong> ${data.genres && data.genres.length > 0 ? data.genres.join(', ') : 'Non spécifiés'}</p>
                                <p><strong>Note:</strong> ${data.rating ? `${data.rating} / 10` : 'Non noté'}</p>
                    <p><strong>Durée:</strong> ${data.duration_readable || 'N/A'}</p> {# NOUVELLE LIGNE POUR LA DURÉE #}
                            </div>
                        </div>`;
                    modalLoader.style.display = 'none';
                    modalContentContainer.classList.remove('d-none');
                })
                .catch(error => {
                    modalLoader.style.display = 'none';
                    modalTitle.textContent = 'Erreur';
                    modalContentContainer.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
                    modalContentContainer.classList.remove('d-none');
                    console.error("Erreur lors du chargement des détails du média:", error);
                });
        }

        // --- Nouvelle logique pour le bouton ARCHIVER FILM ---
        const archiveMovieButton = event.target.closest('.archive-movie-btn');
        if (archiveMovieButton) {
            event.preventDefault();
            const ratingKey = archiveMovieButton.dataset.ratingKey;
            const movieTitle = archiveMovieButton.dataset.title;

            document.getElementById('archiveMovieTitle').textContent = movieTitle;
            // Les options (checkboxes) sont déjà dans la modale, pas besoin de les pré-cocher par défaut ici
            // La modale est ouverte via data-bs-toggle et data-bs-target sur le bouton,
            // donc pas besoin de new bootstrap.Modal(...).show() ici si le HTML est correct.
            // Cependant, pour le flux de confirmation, nous aurons besoin de l'instance de la modale.

            // Le bouton de confirmation est dans la modale, donc on ajoute un écouteur spécifique
            // pour éviter les écouteurs multiples si la modale est ouverte plusieurs fois.
            const confirmBtn = document.getElementById('confirmArchiveMovieBtn');
            const newConfirmBtn = confirmBtn.cloneNode(true); // Pour éviter les listeners multiples
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', function onConfirmArchiveMovie() {
                this.disabled = true;
                this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Archivage...';

                const options = {
                    deleteFiles: document.getElementById('archiveMovieDeleteFiles').checked,
                    unmonitor: document.getElementById('archiveMovieUnmonitor').checked,
                    addTag: document.getElementById('archiveMovieAddTag').checked
                };

                fetch(`{{ url_for('plex_editor.archive_movie_route') }}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ratingKey: ratingKey, options: options })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        archiveMovieButton.closest('tr').remove(); // Supprime la ligne du tableau
                        alert(data.message || 'Film archivé avec succès !');
                        const modalInstance = bootstrap.Modal.getInstance(document.getElementById('archiveMovieModal'));
                        if (modalInstance) modalInstance.hide();
                    } else {
                        alert('Erreur: ' + (data.message || 'Erreur inconnue lors de l_archivage.'));
                    }
                })
                .catch(error => {
                    alert('Erreur de communication avec le serveur.');
                    console.error('Fetch Error (Archive Movie):', error);
                })
                .finally(() => {
                    this.disabled = false;
                    this.innerHTML = 'Confirmer l\'archivage';
                });
            }, { once: true }); // S'assurer que l'event listener est appelé une seule fois
        }

        // --- Nouvelle logique pour le bouton ARCHIVER SÉRIE ---
        const archiveShowButton = event.target.closest('.archive-show-btn');
        if (archiveShowButton) {
            event.preventDefault();
            const ratingKey = archiveShowButton.dataset.ratingKey;
            const showTitle = archiveShowButton.dataset.title;
            const leafCount = archiveShowButton.dataset.leafCount;
            const viewedLeafCount = archiveShowButton.dataset.viewedLeafCount;

            document.getElementById('archiveShowTitle').textContent = showTitle;
            document.getElementById('archiveShowTotalCount').textContent = leafCount || 'N/A';
            document.getElementById('archiveShowViewedCount').textContent = viewedLeafCount || 'N/A';

            const confirmBtn = document.getElementById('confirmArchiveShowBtn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', function onConfirmArchiveShow() {
                this.disabled = true;
                this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Archivage...';

                const options = {
                    deleteFiles: document.getElementById('archiveShowDeleteFiles').checked,
                    unmonitor: document.getElementById('archiveShowUnmonitor').checked,
                    addTag: document.getElementById('archiveShowAddTag').checked
                };

                fetch(`{{ url_for('plex_editor.archive_show_route') }}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ratingKey: ratingKey, options: options })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        archiveShowButton.closest('tr').remove();
                        alert(data.message || 'Série archivée avec succès !');
                        const modalInstance = bootstrap.Modal.getInstance(document.getElementById('archiveShowModal'));
                        if (modalInstance) modalInstance.hide();
                    } else {
                        alert('Erreur: ' + (data.message || 'Erreur inconnue lors de l_archivage de la série.'));
                    }
                })
                .catch(error => {
                    alert('Erreur de communication avec le serveur.');
                    console.error('Fetch Error (Archive Show):', error);
                })
                .finally(() => {
                    this.disabled = false;
                    this.innerHTML = 'Confirmer l\'archivage';
                });
            }, { once: true });
        }

        // --- Nouvelle logique pour le bouton REJETER SÉRIE ---
        const rejectShowButton = event.target.closest('.reject-show-btn');
        if (rejectShowButton) {
            event.preventDefault();
            const ratingKey = rejectShowButton.dataset.ratingKey;
            const showTitle = rejectShowButton.dataset.title;

            document.getElementById('rejectShowTitle').textContent = showTitle;

            const confirmBtn = document.getElementById('confirmRejectShowBtn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', function onConfirmRejectShow() {
                this.disabled = true;
                this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Suppression...';

                fetch(`{{ url_for('plex_editor.reject_show_route') }}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ratingKey: ratingKey })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        rejectShowButton.closest('tr').remove();
                        alert(data.message || 'Série rejetée et marquée pour suppression avec succès !');
                        const modalInstance = bootstrap.Modal.getInstance(document.getElementById('rejectShowModal'));
                        if (modalInstance) modalInstance.hide();
                    } else {
                        alert('Erreur: ' + (data.message || 'Erreur inconnue lors du rejet de la série.'));
                    }
                })
                .catch(error => {
                    alert('Erreur de communication avec le serveur.');
                    console.error('Fetch Error (Reject Show):', error);
                })
                .finally(() => {
                    this.disabled = false;
                    this.innerHTML = 'Oui, rejeter et supprimer';
                });
            }, { once: true });
        }

        // --- Nouvelle logique pour le bouton GÉRER SÉRIE ---
        const manageSeriesButton = event.target.closest('.manage-series-btn');
        if (manageSeriesButton) {
            event.preventDefault();
            const ratingKey = manageSeriesButton.dataset.ratingKey;
            const seriesTitle = manageSeriesButton.dataset.title;

            const modalSeriesTitleElement = document.getElementById('seriesManagementModalTitle');
            if (modalSeriesTitleElement) {
                modalSeriesTitleElement.textContent = seriesTitle || 'Détails de la série';
            }

            const modalBody = document.querySelector('#series-management-modal .modal-body');
            if (modalBody) {
                // Afficher le spinner/loader
                modalBody.innerHTML = `
                    <div class="text-center my-5">
                        <div class="spinner-border text-primary" style="width: 3rem; height: 3rem;" role="status">
                            <span class="visually-hidden">Chargement du contenu de la série...</span>
                        </div>
                        <p class="mt-2">Chargement...</p>
                    </div>`;

                // La modale elle-même est ouverte par data-bs-target, ici on charge le contenu.
                fetch(`{{ url_for('plex_editor.get_series_details_for_management', rating_key=0) }}`.replace('0', ratingKey))
                    .then(response => {
                        if (!response.ok) {
                            return response.text().then(text => {
                                throw new Error(`Erreur HTTP ${response.status}: ${text || 'Erreur serveur inconnue.'}`);
                            });
                        }
                        return response.text();
                    })
                    .then(html => {
                        modalBody.innerHTML = html;
                    })
                    .catch(error => {
                        console.error('Erreur fetch pour les détails de la série:', error);
                        modalBody.innerHTML = `<div class="alert alert-danger">Impossible de charger les détails : ${error.message}</div>`;
                    });
            }
        }
    });

    // --- Logique pour la modale de gestion de série ---
    const seriesModalElement = document.getElementById('series-management-modal');
    if (seriesModalElement) {
        seriesModalElement.addEventListener('click', function(event) {
            const targetElement = event.target;

            // Logique pour supprimer une saison
            const deleteSeasonBtn = targetElement.closest('.delete-season-btn');
            if (deleteSeasonBtn) {
                event.preventDefault();
                const seasonId = deleteSeasonBtn.dataset.seasonId;
                const seasonTitle = deleteSeasonBtn.dataset.seasonTitle || 'cette saison';

                if (confirm(`Êtes-vous sûr de vouloir supprimer les fichiers de ${seasonTitle} et la dé-monitorer ? Cette action est irréversible.`)) {
                    deleteSeasonBtn.disabled = true;
                    deleteSeasonBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Suppr...';

                    fetch(`{{ url_for('plex_editor.delete_season_files_and_unmonitor', season_plex_id=0) }}`.replace('0', seasonId), {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' } // CSRF token géré globalement si nécessaire ou via Flask-WTF pour formulaires
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            alert(data.message || 'Saison traitée pour suppression.');
                            // Optionnel: masquer ou marquer la saison comme supprimée dans l'UI de la modale
                            const seasonAccordionItem = deleteSeasonBtn.closest('.accordion-item');
                            if (seasonAccordionItem) {
                                seasonAccordionItem.classList.add('opacity-50'); // Rendre semi-transparent
                                deleteSeasonBtn.remove(); // Supprimer le bouton
                                const monitorToggle = seasonAccordionItem.querySelector('.season-monitor-toggle');
                                if (monitorToggle) monitorToggle.disabled = true;
                            }
                        } else {
                            alert(`Erreur: ${data.message || 'Impossible de supprimer la saison.'}`);
                        }
                    })
                    .catch(error => {
                        console.error('Erreur suppression saison:', error);
                        alert('Erreur de communication lors de la suppression de la saison.');
                    })
                    .finally(() => {
                        if (!deleteSeasonBtn.closest('.accordion-item')) { // Si le bouton n'a pas été retiré
                           deleteSeasonBtn.disabled = false;
                           deleteSeasonBtn.innerHTML = '<i class="bi bi-trash"></i> <span class="d-none d-sm-inline">Suppr. Saison</span>';
                        }
                    });
                }
            }
        });

        seriesModalElement.addEventListener('change', function(event) {
            const targetElement = event.target;
            // Logique pour le toggle de surveillance de SAISON
            const seasonMonitorToggle = targetElement.closest('.season-monitor-toggle');
            if (seasonMonitorToggle) {
                const seasonId = seasonMonitorToggle.dataset.seasonId;
                const isChecked = seasonMonitorToggle.checked;

                seasonMonitorToggle.disabled = true;

                fetch(`{{ url_for('plex_editor.toggle_season_monitoring', season_plex_id=0) }}`.replace('0', seasonId), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        seasonMonitorToggle.checked = data.monitored;
                    } else {
                        alert(`Erreur: ${data.message || 'Impossible de changer le statut de surveillance de la saison.'}`);
                        seasonMonitorToggle.checked = !isChecked; // Revert
                    }
                })
                .catch(error => {
                    console.error('Erreur toggle surveillance saison:', error);
                    alert('Erreur de communication (surveillance saison).');
                    seasonMonitorToggle.checked = !isChecked; // Revert
                })
                .finally(() => {
                    seasonMonitorToggle.disabled = false;
                });
            }

            // Logique pour le toggle de surveillance GLOBALE DE SÉRIE
            const seriesGlobalMonitorToggle = targetElement.closest('.series-global-monitor-toggle');
            if (seriesGlobalMonitorToggle) {
                const sonarrSeriesId = seriesGlobalMonitorToggle.dataset.sonarrSeriesId;
                const isChecked = seriesGlobalMonitorToggle.checked;

                if (!sonarrSeriesId) {
                    alert("ID de série Sonarr non trouvé. Impossible de changer le statut de surveillance globale.");
                    seriesGlobalMonitorToggle.checked = !isChecked; // Revert
                    return;
                }
                seriesGlobalMonitorToggle.disabled = true;

                fetch(`{{ url_for('plex_editor.toggle_global_series_monitoring', sonarr_series_id=0) }}`.replace('0', sonarrSeriesId), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        seriesGlobalMonitorToggle.checked = data.monitored;
                        // Peut-être mettre à jour les toggles des saisons aussi ? Pour l'instant, non.
                    } else {
                        alert(`Erreur: ${data.message || 'Impossible de changer le statut de surveillance globale.'}`);
                        seriesGlobalMonitorToggle.checked = !isChecked; // Revert
                    }
                })
                .catch(error => {
                    console.error('Erreur toggle surveillance globale:', error);
                    alert('Erreur de communication (surveillance globale).');
                    seriesGlobalMonitorToggle.checked = !isChecked; // Revert
                })
                .finally(() => {
                    seriesGlobalMonitorToggle.disabled = false;
                });
            }
        });
    }
});
</script>
{% endblock %}