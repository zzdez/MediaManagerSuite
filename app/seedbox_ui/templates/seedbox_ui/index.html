<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Seedbox Staging UI - MediaManagerSuite</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* ... Vos styles CSS restent ici ... */
        body { padding-top: 20px; padding-bottom: 60px; }
        .action-buttons form, .action-buttons button { margin-right: 3px; margin-bottom: 3px; }
        ul.file-tree, ul.children-list { list-style-type: none; padding-left: 0; }
        .file-tree li > div { display: flex; align-items: center; padding: 0.25rem 0.5rem; border-bottom: 1px solid #eee; }
        .file-tree li > div:hover { background-color: #f8f9fa; }
        .file-tree .toggle-children { cursor: pointer; color: #0d6efd; text-decoration: none; }
        .file-tree .toggle-children i { transition: transform 0.2s ease-in-out; }
        .file-tree .icon-container { width: 25px; text-align: center; flex-shrink: 0; }
        .file-tree .item-name-details { flex-grow: 1; margin-left: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .file-tree .item-actions { margin-left: auto; flex-shrink: 0; min-width: 280px; } /* Ajustez min-width si besoin pour tous les boutons */
        .file-tree .btn-sm { padding: 0.15rem 0.3rem; font-size: 0.75rem; }
        .modal-lg { max-width: 800px; }
        .btn-toolbar .btn { margin-right: 0.5rem; margin-bottom: 0.5rem;} /* Pour espacer les boutons dans la toolbar */
    </style>
</head>
<body>

{# ========================================================================== #}
{# MACRO JINJA2 POUR RENDRE L'ARBORESCENCE (PLACÉ EN HAUT DU BODY) #}
{# ========================================================================== #}

{% macro render_tree_node(node, can_scan_sonarr, can_scan_radarr, level=0) %}
  <li style="margin-left: {{ level * 20 }}px;">
    <div class="tree-node-item d-flex align-items-center"> {# Ajout de d-flex et align-items-center pour mieux gérer l'alignement vertical #}

      {# --- CASE À COCHER POUR LES ITEMS DE NIVEAU 0 --- #}
      <span style="width: 25px; flex-shrink: 0; text-align: center;"> {# Conteneur pour la case ou l'espace vide #}
          {% if level == 0 %}
              <input type="checkbox" class="form-check-input staging-item-checkbox"
                     value="{{ node.path_for_actions }}"
                     aria-label="Sélectionner {{ node.name }}"
                     style="margin-top: 0; vertical-align: middle;"> {# Style pour mieux aligner #}
          {% endif %}
      </span>
      {# --- FIN CASE À COCHER --- #}

      {# Icône de dossier/fichier #}
      <span class="icon-container" style="width: 25px; text-align: center; flex-shrink: 0;"> {# style="width: 25px; text-align: center;" ajouté ici aussi #}
        {% if node.is_dir and node.children %}
          <a href="#" class="toggle-children me-1" data-bs-toggle="tooltip" title="Déplier/Replier"><i class="fas fa-plus-square"></i></a>
        {% elif node.is_dir %}
          <i class="fas fa-folder text-warning me-1"></i>
        {% else %}
          <i class="fas fa-file text-info me-1"></i>
        {% endif %}
      </span>

      {# Nom de l'item et détails #}
      <span class="item-name-details flex-grow-1" title="{{ node.name }}"> {# flex-grow-1 pour qu'il prenne l'espace restant #}
         {{ node.name }}
         <small class="text-muted" style="font-size: 0.8em;">
             ({{ node.size_readable if node.size_readable else 'N/A' }}, {{ node.last_modified if node.last_modified else 'N/A' }})
         </small>
         {# Display Association Info #}
         {% if node.association %}
            <div class="mt-1">
                <span class="badge {% if node.association.app_type == 'sonarr' %}bg-primary{% elif node.association.app_type == 'radarr' %}bg-warning text-dark{% else %}bg-secondary{% endif %}">
                    <i class="fas fa-link"></i> Associé: {{ node.association.app_type | capitalize }} (ID: {{ node.association.target_id }})
                </span>
                <small class="text-muted d-block">Label rTorrent: {{ node.association.label }}</small>
                {% if node.association.torrent_hash %}
                    <small class="text-muted d-block" title="Hash: {{ node.association.torrent_hash }}">Hash: {{ node.association.torrent_hash | truncate(10) }}...</small>
                {% elif node.association.release_name %}
                    <small class="text-muted d-block">Release: {{ node.association.release_name | truncate(20) }}</small>
                {% endif %}
                {% if node.association.status %}
                    <small class="text-muted d-block">Statut: {{ node.association.status | replace('_', ' ') | capitalize }}</small>
                {% endif %}
                <small class="text-muted d-block">Ajouté: {{ node.association.added_at.split('.')[0].replace('T', ' ') if node.association.added_at else 'N/A' }}</small>
            </div>
         {% endif %}
      </span>

      {# Colonne des Actions #}
      <div class="action-buttons item-actions ms-auto" style="min-width: 300px;"> {# ms-auto pour pousser à droite, ajuster min-width si besoin #}
         {% if not node.name.endswith("(Erreur de lecture)") %}
             {% if level == 0 %}
                {# ... Vos boutons d'action individuels (Mapper Sonarr, Mapper Radarr, Suppr., Nettoyer, Importer Associé) ... #}
                {# ... restent les mêmes qu'avant ... #}
                {% if can_scan_sonarr %}
                <button class="btn btn-sm btn-outline-primary mb-1"
                        onclick='openSonarrSearchModal({{ node.path_for_actions | tojson | safe }}, "{{ 'directory' if node.is_dir else 'file' }}")'
                        title="Rechercher et mapper manuellement avec Sonarr">
                    <i class="fas fa-search"></i> <span class="d-none d-md-inline">Mapper Sonarr</span>
                </button>
                {% endif %}

                {% if can_scan_radarr %}
                <button class="btn btn-sm btn-outline-warning text-dark mb-1"
                        onclick='openRadarrSearchModal({{ node.path_for_actions | tojson | safe }}, "{{ 'directory' if node.is_dir else 'file' }}")'
                        title="Rechercher et mapper manuellement avec Radarr">
                    <i class="fas fa-search"></i> <span class="d-none d-md-inline">Mapper Radarr</span>
                </button>
                {% endif %}

                <form action="{{ url_for('seedbox_ui.delete_item', item_name=node.path_for_actions) }}" method="POST" style="display: inline-block;" onsubmit="return confirm('Supprimer \'{{ node.name | e }}\' ? Cette action est irréversible et supprimera tout le contenu.');">
                    <button type="submit" class="btn btn-sm btn-danger mb-1" title="Supprimer l'item et son contenu du staging">
                        <i class="fas fa-trash-alt"></i> <span class="d-none d-md-inline">Suppr.</span>
                    </button>
                </form>

                {% if node.is_dir %}
                <form action="{{ url_for('seedbox_ui.cleanup_staging_item_action', item_name=node.path_for_actions) }}" method="POST" style="display: inline-block;" onsubmit="return confirm('Nettoyer le dossier \'{{ node.name | e }}\' ?\n\nCeci va :\n1. Supprimer les fichiers orphelins (ex: .nfo, .txt) à l\'intérieur.\n2. Supprimer les sous-dossiers qui deviendraient vides.\n3. Supprimer le dossier principal \'{{ node.name | e }}\' lui-même s\'il devient vide ou ne contient plus que des orphelins (maintenant supprimés).\n\nLes fichiers vidéo ou autres fichiers non-orphelins ne seront PAS supprimés par cette action.');">
                    <button type="submit" class="btn btn-sm btn-warning mb-1" title="Nettoyer le dossier (supprime orphelins et dossiers vides récursivement)">
                        <i class="fas fa-broom"></i> <span class="d-none d-md-inline">Nettoyer</span>
                    </button>
                </form>
                {% endif %}

                {% if node.association %}
                    <form method="POST" action="{{ url_for('seedbox_ui.process_staged_with_association', item_name_in_staging=node.path_for_actions) }}" style="display: inline-block;" onsubmit="return confirm('Lancer l\'importation de \'{{ node.name | e }}\' en utilisant la pré-association ?');">
                        <button type="submit" class="btn btn-sm btn-success mb-1" title="Lancer l'importation en utilisant la pré-association">
                            <i class="fas fa-magic"></i> <span class="d-none d-md-inline">Importer (Associé)</span>
                        </button>
                    </form>
                {% endif %}
             {% endif %}
         {% endif %}
      </div>
    </div>

    {% if node.is_dir and node.children %}
      <ul class="children-list" style="display: none;">
        {% for child_node in node.children %}
          {{ render_tree_node(child_node, can_scan_sonarr, can_scan_radarr, level + 1) }}
        {% endfor %}
      </ul>
    {% endif %}
  </li>
{% endmacro %}


<div class="container mt-4">
    <header class="pb-3 mb-4 border-bottom">
        {# Lien vers la page actuelle pour rafraîchir ou comme titre cliquable #}
        <a href="{{ url_for('seedbox_ui.index') }}" class="d-flex align-items-center text-dark text-decoration-none">
            <span class="fs-4">MediaManagerSuite - Gestion Staging</span>
        </a>
    </header>

    {# Section pour les messages flash #}
    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            {% for category, message in messages %}
            <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                {{ message }}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
            {% endfor %}
        {% endif %}
    {% endwith %}

    {# ========================================================================== #}
    {# BARRE D'OUTILS AVEC LES BOUTONS DE NAVIGATION ET D'ACTION PRINCIPAUX       #}
    {# ========================================================================== #}
    <div class="btn-toolbar mb-3" role="toolbar" aria-label="Toolbar with button groups">
        <div class="btn-group me-2" role="group" aria-label="Navigation group">
            {# Bouton pour retourner au Portail Principal - ASSUMANT 'home' COMME ENDPOINT #}
            <a href="{{ url_for('home') }}" class="btn btn-secondary btn-sm">
                <i class="fas fa-home"></i> Portail
            </a>
            {# Bouton pour la Vue Liste rTorrent #}
            <a href="{{ url_for('seedbox_ui.rtorrent_list_view') }}" class="btn btn-info btn-sm">
                <i class="fas fa-list-alt"></i> Torrents rTorrent
            </a>
        </div>

        <div class="btn-group me-2" role="group" aria-label="Seedbox views group">
            <a href="{{ url_for('seedbox_ui.remote_seedbox_view', app_type_target='sonarr') }}" class="btn btn-outline-primary btn-sm">
                <i class="fas fa-server"></i> Seedbox Sonarr (Terminés)
            </a>
            <a href="{{ url_for('seedbox_ui.remote_seedbox_view', app_type_target='radarr') }}" class="btn btn-outline-primary btn-sm">
                <i class="fas fa-server"></i> Seedbox Radarr (Terminés)
            </a>
        </div>

        <div class="btn-group me-2" role="group" aria-label="Seedbox working views group">
            <a href="{{ url_for('seedbox_ui.remote_seedbox_view', app_type_target='sonarr_working') }}" class="btn btn-outline-secondary btn-sm">
                <i class="fas fa-cogs"></i> Seedbox Sonarr (Travail)
            </a>
            <a href="{{ url_for('seedbox_ui.remote_seedbox_view', app_type_target='radarr_working') }}" class="btn btn-outline-secondary btn-sm">
                <i class="fas fa-cogs"></i> Seedbox Radarr (Travail)
            </a>
        </div>

        <div class="btn-group" role="group" aria-label="Add torrent group">
            <!-- Bouton Ajouter Torrent -->
            <button type="button" class="btn btn-success btn-sm" data-bs-toggle="modal" data-bs-target="#addTorrentModal">
                <i class="fas fa-plus"></i> Ajouter Torrent
            </button>
            {# --- NOUVEAU BOUTON D'ACTION GROUPÉE --- #}
            <button type="button" class="btn btn-primary btn-sm" id="batchMapToSonarrBtn" disabled
                    onclick="openBatchSonarrMapModal()">
                <i class="fas fa-object-group"></i> Mapper Sélection vers Série Sonarr
            </button>
            {# --- FIN NOUVEAU BOUTON --- #}
        </div>
    </div>
    {# FIN DE LA BARRE D'OUTILS #}


{# ========================================================================== #}
{# SECTION POUR LES ITEMS EN ATTENTE / ERREUR                                 #}
{# ========================================================================== #}
{% if items_requiring_attention %}
    <hr class="my-4">
    <h2><i class="fas fa-exclamation-triangle text-warning"></i> Torrents en Attente / Nécessitant Attention</h2>
    <div class="table-responsive">
        <table class="table table-sm table-hover">
            <thead>
                <tr>
                    <th>Release Name</th>
                    <th>Type</th>
                    <th>ID Cible</th>
                    <th>Statut Actuel</th>
                    <th>Message</th>
                    <th>MàJ</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                {% for item in items_requiring_attention %}
                <tr>
                    <td title="{{ item.release_name }}">{{ item.release_name | truncate(60) }}</td>
                    <td>
                        <span class="badge {% if item.app_type == 'sonarr' %}bg-primary{% elif item.app_type == 'radarr' %}bg-warning text-dark{% else %}bg-secondary{% endif %}">
                            {{ item.app_type | capitalize if item.app_type else 'N/A' }}
                        </span>
                    </td>
                    <td>{{ item.target_id if item.target_id is not none else 'N/A' }}</td>
                    <td><span class="badge bg-info text-dark">{{ item.status | replace('_', ' ') | capitalize }}</span></td>
                    <td style="max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="{{ item.status_message }}">{{ item.status_message | truncate(50) if item.status_message else '-' }}</td>
                    <td title="{{ item.updated_at if item.updated_at else item.added_at }}">
                        {{ (item.updated_at if item.updated_at else item.added_at).split('.')[0].replace('T', ' ') if (item.updated_at or item.added_at) else 'N/A' }}
                    </td>
                    <td>
                        {# Bouton Réessayer l'Import (si l'item est dans le staging) #}
                        {% if item.is_in_staging and item.status != 'processing_by_mms_api' %} {# Évite de relancer si déjà en cours #}
                        <form action="{{ url_for('seedbox_ui.retry_problematic_import_action', torrent_hash=item.torrent_hash) }}" method="POST" style="display: inline-block;" onsubmit="return confirm('Réessayer l\'import automatique pour \'{{ item.release_name | e }}\' ?');">
                            <button type="submit" class="btn btn-sm btn-outline-success mb-1" title="Réessayer l'import automatique">
                                <i class="fas fa-redo"></i> Réessayer
                            </button>
                        </form>
                        {% elif item.status == 'processing_by_mms_api' %}
                            <button class="btn btn-sm btn-outline-secondary mb-1" disabled title="Traitement déjà en cours ou bloqué.">
                                <i class="fas fa-spinner fa-spin"></i> En cours...
                            </button>
                        {% endif %}

                        {# Bouton Mapper Manuellement (si applicable) #}
                        {% if item.is_in_staging and item.app_type and item.target_id %}
                            {# Ouvre le modal existant. Le JS devra être adapté pour pré-remplir. #}
                            {% if item.app_type == 'sonarr' %}
                            <button class="btn btn-sm btn-outline-primary mb-1"
                                    onclick='openSonarrSearchModalForProblemItem({{ item.release_name | tojson | safe }}, {{ item.target_id }}, {{ item.torrent_hash | tojson | safe }})'
                                    title="Mapper manuellement avec Sonarr (corriger l'association)">
                                <i class="fas fa-edit"></i> Mapper Sonarr
                            </button>
                            {% elif item.app_type == 'radarr' %}
                            <button class="btn btn-sm btn-outline-warning text-dark mb-1"
                                    onclick='openRadarrSearchModalForProblemItem({{ item.release_name | tojson | safe }}, {{ item.target_id }}, {{ item.torrent_hash | tojson | safe }})'
                                    title="Mapper manuellement avec Radarr (corriger l'association)">
                                <i class="fas fa-edit"></i> Mapper Radarr
                            </button>
                            {% endif %}
                        {% endif %}

                        {# Bouton Supprimer l'Association #}
                        <form action="{{ url_for('seedbox_ui.delete_problematic_association_action', torrent_hash=item.torrent_hash) }}" method="POST" style="display: inline-block;" onsubmit="return confirm('Supprimer cette association en attente pour \'{{ item.release_name | e }}\' ? L\'item physique (s\'il existe) ne sera pas touché.');">
                            <button type="submit" class="btn btn-sm btn-outline-danger mb-1" title="Supprimer cette association de la liste des items en attente">
                                <i class="fas fa-times-circle"></i> Oublier
                            </button>
                        </form>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
{% else %}
    <p class="text-muted">Aucun torrent ne nécessite une attention particulière actuellement.</p>
{% endif %}
{# FIN DE LA SECTION POUR LES ITEMS EN ATTENTE / ERREUR #}

<hr class="my-4"> {# Séparateur avant le contenu du staging local #}
<h1>Contenu du Staging Local</h1>

    {# AFFICHAGE EN ARBORESCENCE (votre code existant) #}
    {% if items_tree %}
        {% if staging_dir_display %}
        <p class="text-muted mb-2">Dossier du Staging Local : <code>{{ staging_dir_display }}</code></p>
        {% endif %}
        <ul class="file-tree">
            {% for root_node in items_tree %}
                {{ render_tree_node(root_node, can_scan_sonarr, can_scan_radarr, 0) }}
            {% endfor %}
        </ul>
    {% elif not get_flashed_messages(category_filter=['danger']) %} {# Évite d'afficher "vide" s'il y a déjà une erreur #}
        <div class="alert alert-info mt-3" role="alert">
            Le dossier de staging local est vide ou non accessible.
        </div>
    {% endif %}
    {# FIN DE L'AFFICHAGE EN ARBORESCENCE #}

</div> {# Fin du container principal #}

{# ========================================================================== #}
{# MODAL POUR AJOUTER UN TORRENT ET PRÉ-ASSOCIER (addTorrentModal)            #}
{# ========================================================================== #}
<div class="modal fade" id="addTorrentModal" tabindex="-1" aria-labelledby="addTorrentModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addTorrentModalLabel">Ajouter un Torrent à rTorrent et Pré-associer</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="addTorrentForm">
                    {# Champs Fichier Torrent et Lien Magnet #}
                    <div class="mb-3">
                        <label for="torrentFileUpload" class="form-label">Fichier .torrent :</label>
                        <input class="form-control form-control-sm" type="file" id="torrentFileUpload" accept=".torrent">
                    </div>
                    <div class="mb-3">
                        <label for="torrentMagnetLink" class="form-label">Ou Lien Magnet :</label>
                        <input type="text" class="form-control form-control-sm" id="torrentMagnetLink" placeholder="magnet:?xt=urn:btih:...">
                    </div>
                    <hr>
                    {# Choix Sonarr/Radarr #}
                    <div class="mb-3">
                        <label class="form-label">Type de Média (pour pré-association) :</label>
                        <div>
                            <input type="radio" class="btn-check" name="addTorrentAppType" id="addTorrentSonarrRadio" value="sonarr" autocomplete="off">
                            <label class="btn btn-outline-primary btn-sm" for="addTorrentSonarrRadio">Sonarr (Série)</label>

                            <input type="radio" class="btn-check" name="addTorrentAppType" id="addTorrentRadarrRadio" value="radarr" autocomplete="off">
                            <label class="btn btn-outline-secondary btn-sm" for="addTorrentRadarrRadio">Radarr (Film)</label>
                        </div>
                    </div>

                    {# Inputs cachés pour stocker les infos de sélection #}
                    <input type="hidden" id="addTorrentTargetId">      {# Stocke l'ID Sonarr/Radarr (si existant) OU TVDB/TMDB ID (si nouveau) #}
                    <input type="hidden" id="addTorrentOriginalName">  {# Nom du fichier torrent ou dn du magnet #}

                    {# Section de recherche qui s'affiche après avoir choisi Sonarr/Radarr #}
                    <div id="addTorrentArrSearchSection" class="mt-3" style="display: none;">
                        <p>Pré-associer avec : <strong id="addTorrentSelectedMediaDisplay">Aucun</strong></p>
                        <div class="input-group mb-3">
                            <input type="text" class="form-control" id="addTorrentArrSearchQuery" placeholder="Rechercher...">
                            <button class="btn btn-outline-info" type="button" id="addTorrentExecuteArrSearchBtn">
                                <i class="fas fa-search"></i> Rechercher
                            </button>
                        </div>
                        <div id="addTorrentArrSearchResults" style="max-height: 250px; overflow-y: auto;">
                            {/* Les résultats de recherche (appelant selectArrItemForAddTorrent) */}
                        </div>
                    </div>

                    {# Options pour l'ajout de NOUVELLE SÉRIE SONARR (UNIQUEMENT DANS addTorrentModal) #}
                    <div id="addTorrentSonarrNewSeriesOptions" class="mt-3 pt-3 border-top" style="display: none;">
                        <h5>Options pour l'ajout de la nouvelle série à Sonarr :</h5>
                        <div class="mb-2">
                            <label for="sonarrRootFolderSelectForAdd" class="form-label form-label-sm">Dossier Racine Sonarr :</label>
                            <select class="form-select form-select-sm" id="sonarrRootFolderSelectForAdd" required>
                                <option value="" selected disabled>Chargement...</option>
                            </select>
                            <div id="sonarrRootFolderErrorForAdd" class="text-danger small mt-1"></div>
                        </div>
                        <div class="mb-2">
                            <label for="sonarrQualityProfileSelectForAdd" class="form-label form-label-sm">Profil de Qualité Sonarr :</label>
                            <select class="form-select form-select-sm" id="sonarrQualityProfileSelectForAdd" required>
                                <option value="" selected disabled>Chargement...</option>
                            </select>
                            <div id="sonarrQualityProfileErrorForAdd" class="text-danger small mt-1"></div>
                        </div>
                        {# TODO: Ajouter Language Profile select pour Sonarr si nécessaire #}
                    </div>

                    {# Options pour l'ajout de NOUVEAU FILM RADARR (UNIQUEMENT DANS addTorrentModal) #}
                    <div id="addTorrentRadarrNewMovieOptions" class="mt-3 pt-3 border-top" style="display: none;">
                        <h5>Options pour l'ajout du nouveau film à Radarr :</h5>
                        <div class="mb-2">
                            <label for="radarrRootFolderSelectForAdd" class="form-label form-label-sm">Dossier Racine Radarr :</label>
                            <select class="form-select form-select-sm" id="radarrRootFolderSelectForAdd" required>
                                <option value="" selected disabled>Chargement...</option>
                            </select>
                            <div id="radarrRootFolderErrorForAdd" class="text-danger small mt-1"></div>
                        </div>
                        <div class="mb-2">
                            <label for="radarrQualityProfileSelectForAdd" class="form-label form-label-sm">Profil de Qualité Radarr :</label>
                            <select class="form-select form-select-sm" id="radarrQualityProfileSelectForAdd" required>
                                <option value="" selected disabled>Chargement...</option>
                            </select>
                            <div id="radarrQualityProfileErrorForAdd" class="text-danger small mt-1"></div>
                        </div>
                         <div class="mb-2">
                            <label for="radarrMinimumAvailabilitySelectForAdd" class="form-label form-label-sm">Disponibilité Minimale :</label>
                            <select class="form-select form-select-sm" id="radarrMinimumAvailabilitySelectForAdd" required>
                                <option value="announced" selected>Announced</option>
                                <option value="inCinemas">In Cinemas</option>
                                <option value="released">Released (Physique/Web)</option>
                                <option value="preDB">PreDB</option> {# Généralement pas recommandé pour l'ajout auto #}
                            </select>
                        </div>
                    </div>
                    <div id="addTorrentFeedback" class="mt-3"></div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                <button type="button" class="btn btn-primary" id="submitAddTorrentBtn">Lancer et Pré-associer</button>
            </div>
        </div>
    </div>
</div>


{# ========================================================================== #}
{# MODAL GÉNÉRIQUE POUR RECHERCHE/MAPPING SONARR (utilisé par staging, etc.)  #}
{# ========================================================================== #}
<div class="modal fade" id="sonarrSearchModal" tabindex="-1" aria-labelledby="sonarrSearchModalGenericLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="sonarrSearchModalGenericLabel">Mapper à une Série Sonarr</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Item en cours de mapping : <strong id="sonarrItemToMap"></strong> (<span id="sonarrItemType"></span>)</p>
                <input type="hidden" id="sonarrOriginalItemName" value=""> {# Stocke le path_for_actions de l'item du staging/seedbox #}
                <input type="hidden" id="sonarrOriginalItemType" value="">

                <div class="input-group mb-3">
                    <input type="text" class="form-control" id="sonarrSearchQuery" placeholder="Nom de la série...">
                    <button class="btn btn-outline-primary" type="button" onclick="executeSonarrSearch()"> {# Appelle executeSonarrSearch (générique) #}
                        <i class="fas fa-search"></i> Rechercher
                    </button>
                </div>
                <div id="sonarrSearchResults" class="mb-3" style="max-height: 300px; overflow-y: auto;"></div>

                <input type="hidden" id="sonarrSelectedSeriesId"> {# Stocke l'ID Sonarr (interne ou TVDB) #}
                <p id="sonarrSelectedSeriesTitle" class="fw-bold mt-2">Aucune série sélectionnée</p>

                <div id="sonarrManualSeasonDiv" class="mb-3" style="display: none;">
                    <label for="sonarrManualSeasonInput" class="form-label form-label-sm">Forcer la Saison (optionnel) :</label>
                    <input type="number" class="form-control form-control-sm" id="sonarrManualSeasonInput" placeholder="Ex: 1">
                </div>

                {# PAS de addTorrentSonarrNewSeriesOptions ici, car ce modal n'ajoute pas de NOUVELLE série à Sonarr. #}
                {# S'il faut ajouter une série qui n'existe pas, l'utilisateur doit passer par "Ajouter Torrent". #}
                {# Ou alors, on complexifie ce modal pour qu'il gère aussi l'ajout, mais c'est l'étape d'après. #}
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                <button type="button" class="btn btn-primary" id="sonarrModalMapButton">Mapper</button> {# Texte et action gérés par JS #}
            </div>
        </div>
    </div>
</div>


{# ========================================================================== #}
{# MODAL GÉNÉRIQUE POUR RECHERCHE/MAPPING RADARR (utilisé par staging, etc.)  #}
{# ========================================================================== #}
<div class="modal fade" id="radarrSearchModal" tabindex="-1" aria-labelledby="radarrSearchModalGenericLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="radarrSearchModalGenericLabel">Mapper à un Film Radarr</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Item en cours de mapping : <strong id="radarrItemToMap"></strong> (<span id="radarrItemType"></span>)</p>
                <input type="hidden" id="radarrOriginalItemName" value="">
                <input type="hidden" id="radarrOriginalItemType" value="">

                <div class="input-group mb-3">
                    <input type="text" class="form-control" id="radarrSearchQuery" placeholder="Titre du film...">
                    <button class="btn btn-outline-primary" type="button" onclick="executeRadarrSearch()"> {# Appelle executeRadarrSearch (générique) #}
                        <i class="fas fa-search"></i> Rechercher
                    </button>
                </div>
                <div id="radarrSearchResults" class="mb-3" style="max-height: 300px; overflow-y: auto;"></div>

                <input type="hidden" id="radarrSelectedMovieId"> {# Stocke l'ID Radarr (interne ou TMDB) #}
                <p id="radarrSelectedMovieTitle" class="fw-bold mt-2">Aucun film sélectionné</p>

                {# PAS de addTorrentRadarrNewMovieOptions ici #}
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                <button type="button" class="btn btn-primary" id="radarrModalMapButton">Mapper</button> {# Texte et action gérés par JS #}
            </div>
        </div>
    </div>
</div>

    <!-- Bootstrap Bundle JS (Popper.js included) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

    <script>
        {# // const csrfToken = "{{ csrf_token() }}"; #}

        function escapeJsString(str) {
            if (str === null || typeof str === 'undefined') { return ''; }
            return String(str).replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/</g, '\\u003C').replace(/>/g, '\\u003E').replace(/&/g, '\\u0026');
        }

        function getCleanedSearchTerm(itemName) { // itemName est le path_for_actions ici
            const baseNameForSearch = itemName.split(/[\\/]/).pop();
            let cleanedName = baseNameForSearch;

            cleanedName = cleanedName.replace(/\.(mkv|mp4|avi|srt|nfo|jpg|png)$/i, '');
            cleanedName = cleanedName.replace(/[\.\[\(]?\d{3,4}p[\.\]\)]?/i, '');
            cleanedName = cleanedName.replace(/[\.\[\(]?(hdtv|web-dl|webrip|bluray|x264|x265|h264|h265|hevc|ac3|dts|multi|vf|vof|french|truefrench|fanart|pack)[\.\]\)]?/gi, ''); // Ajout de pack
            cleanedName = cleanedName.replace(/[\.\[\(]?S\d{1,3}(E\d{1,3}(-E?\d{1,3}(\s?-\s?E?\d{1,3})?)?)?[\.\]\)]?/i, ''); // Amélioré pour S01E01-E05
            cleanedName = cleanedName.replace(/[\.\[\(]?\d{4}[\.\]\)]?$/, '');
            cleanedName = cleanedName.replace(/[\._-]+/g, ' ').replace(/\s+/g, ' ').trim();
            return cleanedName || baseNameForSearch.split('.')[0];
        }

        function openSonarrSearchModal(itemPathForAction, itemType) { // itemPathForAction est node.path_for_actions
            const itemNameForDisplay = itemPathForAction.split(/[\\/]/).pop();

            // --- NOUVEAU : Récupérer l'élément du modal et définir le contexte ---
            const sonarrModalElement = document.getElementById('sonarrSearchModal');
            if (!sonarrModalElement) {
                console.error("Modal Sonarr (ID: sonarrSearchModal) non trouvé lors de l'ouverture pour mapping individuel!");
                return;
            }
            sonarrModalElement.setAttribute('data-current-action', 'mapIndividualStaging'); // Contexte pour le mapping individuel depuis le staging
            sonarrModalElement.removeAttribute('data-is-new-series'); // Nettoyer les anciens états
            sonarrModalElement.removeAttribute('data-selected-media-id');
            sonarrModalElement.removeAttribute('data-selected-media-title');
            sonarrModalElement.removeAttribute('data-problem-torrent-hash'); // Nettoyer aussi s'il était là
            // --- FIN NOUVEAU ---

            document.getElementById('sonarrItemToMap').textContent = itemNameForDisplay;
            document.getElementById('sonarrOriginalItemName').value = itemPathForAction;
            document.getElementById('sonarrOriginalItemType').value = itemType;
            document.getElementById('sonarrItemType').textContent = itemType === 'directory' ? 'Dossier (Staging)' : 'Fichier (Staging)';

            const searchQueryInput = document.getElementById('sonarrSearchQuery');
            if (searchQueryInput) searchQueryInput.value = getCleanedSearchTerm(itemPathForAction);

            const searchResultsDiv = document.getElementById('sonarrSearchResults');
            if (searchResultsDiv) searchResultsDiv.innerHTML = '';

            document.getElementById('sonarrSelectedSeriesId').value = '';
            document.getElementById('sonarrSelectedSeriesTitle').innerText = 'Aucune série sélectionnée';

            // La visibilité de sonarrManualSeasonDiv sera gérée par handleGenericSonarrSeriesSelection
            // en fonction de data-current-action et si la série est nouvelle/existante.
            // On peut s'assurer qu'il est caché initialement si on veut, ou laisser handleGeneric... le gérer.
            const manualSeasonDiv = document.getElementById('sonarrManualSeasonDiv');
            if(manualSeasonDiv) manualSeasonDiv.style.display = 'none'; // Cacher par défaut, handleGeneric... le montrera si besoin
            document.getElementById('sonarrManualSeasonInput').value = '';

            currentlySelectedSonarrSeriesIdInModal = null;

            const modalMapButton = document.getElementById('sonarrModalMapButton');
            if (modalMapButton) {
                modalMapButton.innerHTML = '<i class="fas fa-link"></i> Mapper à cette Série'; // Texte par défaut pour mapping individuel
                modalMapButton.disabled = true;
                modalMapButton.classList.remove('btn-info'); // S'assurer qu'il a le style par défaut
                modalMapButton.classList.add('btn-primary');

                modalMapButton.onclick = function() {
                    const seriesId = document.getElementById('sonarrSelectedSeriesId').value; // Ou currentlySelectedSonarrSeriesIdInModal
                    const seriesTitle = document.getElementById('sonarrSelectedSeriesTitle').innerText.replace('Série sélectionnée : ', '');
                    const userForcedSeason = document.getElementById('sonarrManualSeasonInput').value;

                    // Lire les attributs data- du modal pour savoir si c'est un ajout
                    const isNewSeries = sonarrModalElement.getAttribute('data-is-new-series') === 'true';
                    const mediaIdForPayload = sonarrModalElement.getAttribute('data-selected-media-id'); // tvdbId si nouveau, seriesId si existant
                    const mediaTitleForAdd = sonarrModalElement.getAttribute('data-selected-media-title'); // Titre pour l'ajout

                    if (mediaIdForPayload) { // mediaIdForPayload contient l'ID pertinent (Sonarr ou TVDB)
                        triggerSonarrManualImportWithSeason(
                            mediaIdForPayload, // Passer l'ID stocké (Sonarr ID ou TVDB ID)
                            seriesTitle,       // Titre pour affichage (non utilisé par backend si existant)
                            userForcedSeason,
                            isNewSeries,       // Nouveau paramètre booléen
                            mediaTitleForAdd   // Nouveau paramètre (titre si ajout)
                            // problem_torrent_hash n'est pas pertinent pour ce flux (mapping depuis staging)
                        );
                    } else {
                        alert("Veuillez sélectionner une série.");
                    }
                };
            }

            var modal = new bootstrap.Modal(sonarrModalElement);
            modal.show();
        }

function openRadarrSearchModal(itemPathForAction, itemType) { // itemPathForAction est node.path_for_actions
    const itemNameForDisplay = itemPathForAction.split(/[\\/]/).pop();

    // Mettre à jour les infos de l'item en cours de mapping
    document.getElementById('radarrItemToMap').textContent = itemNameForDisplay;
    document.getElementById('radarrOriginalItemName').value = itemPathForAction;
    document.getElementById('radarrOriginalItemType').value = itemType;
    document.getElementById('radarrItemType').textContent = itemType === 'directory' ? 'Dossier (Staging)' : 'Fichier (Staging)';

    // Réinitialiser les champs de recherche et de sélection
    const searchQueryInput = document.getElementById('radarrSearchQuery');
    if (searchQueryInput) searchQueryInput.value = getCleanedSearchTerm(itemPathForAction); // Pré-remplir la recherche

    const searchResultsDiv = document.getElementById('radarrSearchResults');
    if (searchResultsDiv) searchResultsDiv.innerHTML = '';

    const selectedMovieIdInput = document.getElementById('radarrSelectedMovieId');
    if (selectedMovieIdInput) selectedMovieIdInput.value = '';

    const selectedMovieTitleDisplay = document.getElementById('radarrSelectedMovieTitle');
    if (selectedMovieTitleDisplay) selectedMovieTitleDisplay.innerText = 'Aucun film sélectionné';

    // Configurer le bouton de mapping du modal
    const modalMapButton = document.getElementById('radarrModalMapButton');
    if (modalMapButton) {
        modalMapButton.innerHTML = '<i class="fas fa-link"></i> Mapper à ce Film';
        modalMapButton.disabled = true; // Désactiver jusqu'à sélection
        modalMapButton.onclick = function() {
            const movieId = document.getElementById('radarrSelectedMovieId').value;
            // const movieTitle = document.getElementById('radarrSelectedMovieTitle').innerText.replace('Film sélectionné : ', ''); // Pour affichage seulement
            if (movieId) {
                triggerRadarrManualImport(movieId); // Appelle votre fonction de soumission pour Radarr
            } else {
                alert("Veuillez sélectionner un film.");
            }
        };
    } else {
        console.error("Bouton de mapping (ID: radarrModalMapButton) non trouvé dans le modal Radarr.");
    }

    var radarrModal = new bootstrap.Modal(document.getElementById('radarrSearchModal'));
    radarrModal.show();
}
        // ==================================================================================
        // NOUVELLES FONCTIONS JS POUR LES ITEMS PROBLÉMATIQUES
        // ==================================================================================
function openSonarrSearchModalForProblemItem(releaseName, currentTargetId, torrentHash) {
            console.log("Ouverture Modal Sonarr pour item problématique:", releaseName, "ID actuel:", currentTargetId, "Hash:", torrentHash);
            currentItemToMap = releaseName; // C'est le nom de la release
            currentItemType = 'problem_item';

            // --- AJOUT DE LA MISE À JOUR DE L'INPUT CACHÉ ---
            const originalItemNameInput = document.getElementById('sonarrOriginalItemName'); // ID de l'input caché dans le modal Sonarr
            if (originalItemNameInput) {
                originalItemNameInput.value = releaseName; // releaseName est le item_name_in_staging
            } else {
                console.error("L'input caché 'sonarrOriginalItemName' est introuvable dans le modal Sonarr !");
            }
            // --- FIN DE L'AJOUT ---

            const searchQueryInput = document.getElementById('sonarrSearchQuery');
            const searchResultsDiv = document.getElementById('sonarrSearchResults');
            const selectedSeriesIdInput = document.getElementById('sonarrSelectedSeriesId');
            const selectedSeriesTitleDisplay = document.getElementById('sonarrSelectedSeriesTitle');
            const manualSeasonDiv = document.getElementById('sonarrManualSeasonDiv');
            const manualSeasonInput = document.getElementById('sonarrManualSeasonInput');
            const modalElement = document.getElementById('sonarrSearchModal'); // ID de la div racine du modal Sonarr

            if (searchQueryInput) searchQueryInput.value = getCleanedSearchTerm(releaseName);
            if (searchResultsDiv) searchResultsDiv.innerHTML = '';
            if (selectedSeriesIdInput) selectedSeriesIdInput.value = currentTargetId || '';

            if (selectedSeriesTitleDisplay) {
                if (currentTargetId) {
                    selectedSeriesTitleDisplay.innerText = `Série actuelle (problème): ID ${currentTargetId} (Recherchez pour changer)`;
                } else {
                    selectedSeriesTitleDisplay.innerText = 'Aucune série sélectionnée';
                }
            }
            if (manualSeasonDiv) manualSeasonDiv.style.display = currentTargetId ? 'block' : 'none';
            if (manualSeasonInput) manualSeasonInput.value = '';

            if (modalElement) {
                modalElement.setAttribute('data-problem-torrent-hash', torrentHash || '');
                var modal = new bootstrap.Modal(modalElement);
                modal.show();
            } else {
                console.error("Élément racine du modal Sonarr (ID: 'sonarrSearchModal') non trouvé pour les items problématiques.");
            }
        }

        function openRadarrSearchModalForProblemItem(releaseName, currentTargetId, torrentHash) {
            console.log("Ouverture Modal Radarr pour item problématique:", releaseName, "ID actuel:", currentTargetId, "Hash:", torrentHash);
            currentItemToMap = releaseName;
            currentItemType = 'problem_item';

            // --- AJOUT DE LA MISE À JOUR DE L'INPUT CACHÉ ---
            const originalItemNameInput = document.getElementById('radarrOriginalItemName'); // ID de l'input caché dans le modal Radarr
            if (originalItemNameInput) {
                originalItemNameInput.value = releaseName; // releaseName est le item_name_in_staging
            } else {
                console.error("L'input caché 'radarrOriginalItemName' est introuvable dans le modal Radarr !");
            }
            // --- FIN DE L'AJOUT ---

            const searchQueryInput = document.getElementById('radarrSearchQuery');
            const searchResultsDiv = document.getElementById('radarrSearchResults');
            const selectedMovieIdInput = document.getElementById('radarrSelectedMovieId');
            const selectedMovieTitleDisplay = document.getElementById('radarrSelectedMovieTitle');
            const modalElement = document.getElementById('radarrSearchModal'); // ID de la div racine du modal Radarr

            if (searchQueryInput) searchQueryInput.value = getCleanedSearchTerm(releaseName);
            if (searchResultsDiv) searchResultsDiv.innerHTML = '';
            if (selectedMovieIdInput) selectedMovieIdInput.value = currentTargetId || '';

            if (selectedMovieTitleDisplay) {
                if (currentTargetId) {
                    selectedMovieTitleDisplay.innerText = `Film actuel (problème): ID ${currentTargetId} (Recherchez pour changer)`;
                } else {
                    selectedMovieTitleDisplay.innerText = 'Aucun film sélectionné';
                }
            }

            if (modalElement) {
                modalElement.setAttribute('data-problem-torrent-hash', torrentHash || '');
                var modal = new bootstrap.Modal(modalElement);
                modal.show();
            } else {
                console.error("Élément racine du modal Radarr (ID: 'radarrSearchModal') non trouvé pour les items problématiques.");
            }
        }

        const batchMapButton = document.getElementById('batchMapToSonarrBtn');
        const stagingItemCheckboxes = document.querySelectorAll('.staging-item-checkbox');
        let selectedStagingItemsForBatch = []; // Pour stocker les path_for_actions des items cochés

        // Fonction pour mettre à jour l'état du bouton d'action groupée
        function updateBatchActionButtonState() {
            selectedStagingItemsForBatch = [];
            stagingItemCheckboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedStagingItemsForBatch.push(checkbox.value);
                }
            });

            if (batchMapButton) {
                batchMapButton.disabled = selectedStagingItemsForBatch.length === 0;
            }
        }

        // Ajouter des écouteurs d'événements aux cases à cocher
        stagingItemCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', updateBatchActionButtonState);
        });

        // Appeler une fois au chargement pour initialiser l'état du bouton (si des cases sont cochées par défaut, peu probable ici)
        // updateBatchActionButtonState(); // Généralement pas nécessaire au chargement initial avec des cases non cochées

        function openBatchSonarrMapModal() {
            if (selectedStagingItemsForBatch.length === 0) { // selectedStagingItemsForBatch est remplie par updateBatchActionButtonState
                alert("Veuillez sélectionner au moins un item du staging.");
                return;
            }
            console.log("Batch Map: Ouvrir modal pour items:", selectedStagingItemsForBatch);

            const sonarrModalElement = document.getElementById('sonarrSearchModal');
            if (!sonarrModalElement) {
                console.error("Modal Sonarr (ID: sonarrSearchModal) non trouvé !");
                return;
            }

            // Réinitialiser les champs du modal
            document.getElementById('sonarrSearchQuery').value = '';
            document.getElementById('sonarrSearchResults').innerHTML = `<p class="text-muted">Recherchez une série Sonarr pour mapper les <strong>${selectedStagingItemsForBatch.length} items</strong> sélectionnés.</p>`;

            // Ces éléments existent maintenant grâce à la modification du HTML du modal
            document.getElementById('sonarrSelectedSeriesId').value = '';
            document.getElementById('sonarrSelectedSeriesTitle').innerText = 'Aucune série sélectionnée';
            document.getElementById('sonarrManualSeasonDiv').style.display = 'none';
            document.getElementById('sonarrManualSeasonInput').value = '';

            currentlySelectedSonarrSeriesIdInModal = null; // Réinitialiser l'ID sélectionné

            // Configurer le bouton de soumission du modal pour l'action de batch
            const modalMapButton = document.getElementById('sonarrModalMapButton');
            if (modalMapButton) {
                modalMapButton.innerHTML = '<i class="fas fa-object-group"></i> Mapper Sélection à cette Série';
                modalMapButton.disabled = true; // Désactiver jusqu'à ce qu'une série soit sélectionnée

                // Définir l'action onclick pour le bouton de mapping du modal
                modalMapButton.onclick = function() {
                    if (currentlySelectedSonarrSeriesIdInModal) {
                        triggerBatchSonarrMapAction(currentlySelectedSonarrSeriesIdInModal);
                    } else {
                        alert("Veuillez d'abord rechercher et sélectionner une série dans la liste.");
                    }
                };
            } else {
                console.error("Bouton de mapping (ID: sonarrModalMapButton) non trouvé dans le modal Sonarr.");
            }

            var modal = new bootstrap.Modal(sonarrModalElement);
            modal.show();
        }

        async function triggerBatchSonarrMapAction(selectedSeriesIdForBatch) {
        // Vérifier si selectedSeriesIdForBatch est valide
        if (!selectedSeriesIdForBatch) {
            alert("Aucune série Sonarr n'a été sélectionnée pour le mapping groupé.");
            return;
        }
        if (selectedStagingItemsForBatch.length === 0) {
            alert("Aucun item du staging n'est sélectionné pour le mapping groupé.");
            return;
        }

        const payload = {
            item_names: selectedStagingItemsForBatch,
            series_id: parseInt(selectedSeriesIdForBatch)
        };

        console.log("Payload pour batch map Sonarr:", payload);
        const resultsDivInModal = document.getElementById('sonarrSearchResults');
        if(resultsDivInModal) resultsDivInModal.innerHTML = `<div class="alert alert-info">Traitement groupé en cours pour ${selectedStagingItemsForBatch.length} items...</div>`;

        const modalMapButton = document.getElementById('sonarrModalMapButton');
        if(modalMapButton) modalMapButton.disabled = true;

        try {
            const response = await fetch("{{ url_for('seedbox_ui.batch_map_to_sonarr_series_action') }}", {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            if (response.ok && result.success) {
                let message = `Traitement groupé terminé. ${result.processed_count || 0} items traités avec succès.`;
                if (result.errors_count && result.errors_count > 0) {
                    message += ` ${result.errors_count} items ont échoué ou nécessité une attention.`;
                    if(resultsDivInModal) resultsDivInModal.innerHTML = `<div class="alert alert-warning">${escapeJsString(message)}<br>Détails dans les logs.</div>`;
                } else {
                    if(resultsDivInModal) resultsDivInModal.innerHTML = `<div class="alert alert-success">${escapeJsString(message)}</div>`;
                }
                flashMessageGlobally(message, (result.errors_count && result.errors_count > 0) ? 'warning' : 'success');
                setTimeout(() => {
                    const modalInstance = bootstrap.Modal.getInstance(document.getElementById('sonarrSearchModal'));
                    if (modalInstance) modalInstance.hide();
                    window.location.reload();
                }, 3500); // Un peu plus de temps pour lire le message dans le modal
            } else {
                throw new Error(result.error || `Erreur HTTP ${response.status} lors du traitement groupé.`);
            }
        } catch (error) {
            console.error('Erreur lors du mapping Sonarr groupé:', error);
            if(resultsDivInModal) resultsDivInModal.innerHTML = `<div class="alert alert-danger">Erreur: ${escapeJsString(error.message)}</div>`;
            flashMessageGlobally(`Erreur lors du mapping groupé: ${escapeJsString(error.message)}`, 'danger');
        } finally {
            if(modalMapButton) modalMapButton.disabled = false;
        }
    }

        // ==================================================================================
        // NOUVELLE FONCTION HELPER POUR LA SÉLECTION D'UNE SÉRIE DANS LE MODAL SONARR
        // (appelée par executeSonarrSearch)
        // ==================================================================================
        // MODIFIÉE pour accepter et utiliser 'isAdded'
        function handleSonarrSeriesSelectionInModal(mediaId, seriesTitle, isAdded) {
            console.log(`handleSonarrSeriesSelectionInModal: mediaId=${mediaId}, title=${seriesTitle}, isAdded=${isAdded}`);

            const selectedSeriesIdInput = document.getElementById('sonarrSelectedSeriesId');
            const selectedSeriesTitleDisplay = document.getElementById('sonarrSelectedSeriesTitle');
            const modalMapButton = document.getElementById('sonarrModalMapButton');
            const resultsDiv = document.getElementById('sonarrSearchResults');
            const sonarrModalElement = document.getElementById('sonarrSearchModal');

            // NOUVEAU : Références aux nouveaux éléments HTML pour l'ajout de série
            const newSeriesOptionsDiv = document.getElementById('sonarrNewSeriesOptions');
            const rootFolderSelect = document.getElementById('sonarrRootFolderSelect');
            const qualityProfileSelect = document.getElementById('sonarrQualityProfileSelect');
            const rootFolderErrorDiv = document.getElementById('sonarrRootFolderError');
            const qualityProfileErrorDiv = document.getElementById('sonarrQualityProfileError');

            if (selectedSeriesIdInput) selectedSeriesIdInput.value = mediaId;
            if (selectedSeriesTitleDisplay) selectedSeriesTitleDisplay.innerText = `Série sélectionnée : ${seriesTitle}`;

            currentlySelectedSonarrSeriesIdInModal = mediaId;

            if (sonarrModalElement) {
                sonarrModalElement.setAttribute('data-is-new-series', isAdded ? 'false' : 'true');
                sonarrModalElement.setAttribute('data-selected-media-id', mediaId);
                sonarrModalElement.setAttribute('data-selected-media-title', seriesTitle); // Stocker le titre non échappé si possible
            }

            if (modalMapButton) {
                modalMapButton.disabled = !mediaId;
                if (!isAdded) {
                    modalMapButton.innerHTML = '<i class="fas fa-plus-circle"></i> Ajouter & Mapper Sélection';
                    modalMapButton.classList.remove('btn-primary');
                    modalMapButton.classList.add('btn-info');
                } else {
                    modalMapButton.classList.remove('btn-info');
                    modalMapButton.classList.add('btn-primary');
                    // Le texte du bouton pour "Mapper existant" est déjà géré par la fonction qui ouvre le modal
                }
            }

            if(resultsDiv) {
                resultsDiv.innerHTML = `<p class="alert alert-info mt-2">Série sélectionnée : <strong>${seriesTitle}</strong> (ID: ${mediaId}).<br>
                    ${isAdded ? 'Cette série est déjà gérée par Sonarr. Prêt à mapper.' : 'Cette série sera ajoutée à Sonarr puis mappée.'}<br>
                    ${!isAdded ? 'Veuillez choisir un dossier racine et un profil de qualité ci-dessous.<br>' : ''}
                    Cliquez sur le bouton d'action en bas du modal.</p>`;
            }

            // Gérer l'affichage de la div pour la saison manuelle
            const manualSeasonDiv = document.getElementById('sonarrManualSeasonDiv');
            if (manualSeasonDiv) {
                const currentAction = sonarrModalElement ? sonarrModalElement.getAttribute('data-current-action') : null;
                if (isAdded && (currentAction === 'mapIndividualStaging' || currentAction === 'mapProblemItem')) {
                    manualSeasonDiv.style.display = 'block';
                } else {
                    manualSeasonDiv.style.display = 'none';
                }
            }

            // --- NOUVEAU : Gérer l'affichage des options pour nouvelle série ---
            if (newSeriesOptionsDiv && rootFolderSelect && qualityProfileSelect) {
                if (!isAdded) { // Si c'est une NOUVELLE série à ajouter
                    newSeriesOptionsDiv.style.display = 'block';
                    // Désactiver le bouton de mapping tant que les options ne sont pas chargées/choisies
                    if(modalMapButton) modalMapButton.disabled = true;

                    // Vider les options précédentes et afficher "Chargement..."
                    rootFolderSelect.innerHTML = '<option value="">Chargement des dossiers racine...</option>';
                    qualityProfileSelect.innerHTML = '<option value="">Chargement des profils de qualité...</option>';
                    rootFolderSelect.disabled = true;
                    qualityProfileSelect.disabled = true;
                    if(rootFolderErrorDiv) rootFolderErrorDiv.textContent = '';
                    if(qualityProfileErrorDiv) qualityProfileErrorDiv.textContent = '';

                    // Appeler les fonctions pour peupler les selects (nous les créerons ensuite)
                    populateSonarrRootFolders(rootFolderSelect, rootFolderErrorDiv, modalMapButton);
                    populateSonarrQualityProfiles(qualityProfileSelect, qualityProfileErrorDiv, modalMapButton);
                } else { // Si la série est déjà ajoutée, cacher ces options
                    newSeriesOptionsDiv.style.display = 'none';
                    if(modalMapButton) modalMapButton.disabled = !mediaId; // Réactiver si un mediaId est là
                }
            } else {
                console.warn("Éléments HTML pour les options de nouvelle série (sonarrNewSeriesOptions, etc.) non trouvés.");
            }
            // --- FIN NOUVEAU ---
        }

        // --- NOUVELLES FONCTIONS POUR PEUPLER LES SELECTS (à placer avec vos autres fonctions JS) ---
        async function populateSonarrRootFolders(selectElement, errorElement, mapButtonToEnable) {
            try {
                const response = await fetch("{{ url_for('seedbox_ui.get_sonarr_rootfolders_api') }}"); // NOUVELLE ROUTE BACKEND
                if (!response.ok) throw new Error(`Erreur HTTP ${response.status} lors de la récupération des dossiers racine.`);
                const rootFolders = await response.json();

                selectElement.innerHTML = '<option value="">-- Choisir un dossier racine --</option>'; // Option par défaut
                if (rootFolders && rootFolders.length > 0) {
                    rootFolders.forEach(folder => {
                        // L'API Sonarr /rootfolder retourne des objets avec 'path' et 'id' (l'id n'est pas utilisé pour l'ajout, c'est le path)
                        // Mais pour l'ajout de série, Sonarr attend le 'rootFolderPath' (le chemin)
                        selectElement.add(new Option(folder.path, folder.path)); // Valeur = chemin
                    });
                    selectElement.disabled = false;
                } else {
                    selectElement.innerHTML = '<option value="">Aucun dossier racine configuré dans Sonarr</option>';
                    if(errorElement) errorElement.textContent = "Aucun dossier racine Sonarr trouvé.";
                }
            } catch (error) {
                console.error("Erreur populateSonarrRootFolders:", error);
                selectElement.innerHTML = '<option value="">Erreur chargement</option>';
                if(errorElement) errorElement.textContent = `Erreur: ${error.message}`;
            }
            // Activer le bouton de mapping principal si les deux selects sont prêts (ou si l'un n'est pas nécessaire)
            checkAndEnableMapButton(mapButtonToEnable);
        }

        async function populateSonarrQualityProfiles(selectElement, errorElement, mapButtonToEnable) {
            try {
                const response = await fetch("{{ url_for('seedbox_ui.get_sonarr_qualityprofiles_api') }}"); // NOUVELLE ROUTE BACKEND
                if (!response.ok) throw new Error(`Erreur HTTP ${response.status} lors de la récupération des profils de qualité.`);
                const qualityProfiles = await response.json();

                selectElement.innerHTML = '<option value="">-- Choisir un profil de qualité --</option>';
                if (qualityProfiles && qualityProfiles.length > 0) {
                    qualityProfiles.forEach(profile => {
                        selectElement.add(new Option(profile.name, profile.id)); // Valeur = ID du profil
                    });
                    selectElement.disabled = false;
                } else {
                    selectElement.innerHTML = '<option value="">Aucun profil de qualité trouvé dans Sonarr</option>';
                    if(errorElement) errorElement.textContent = "Aucun profil de qualité Sonarr trouvé.";
                }
            } catch (error) {
                console.error("Erreur populateSonarrQualityProfiles:", error);
                selectElement.innerHTML = '<option value="">Erreur chargement</option>';
                if(errorElement) errorElement.textContent = `Erreur: ${error.message}`;
            }
            checkAndEnableMapButton(mapButtonToEnable);
        }

        function checkAndEnableMapButton(mapButton) {
            // Activer le bouton de mapping principal si une série est sélectionnée ET
            // (si c'est une nouvelle série) si un root folder et un quality profile sont sélectionnés.
            if (!mapButton) return;

            const sonarrModalElement = document.getElementById('sonarrSearchModal');
            const isNew = sonarrModalElement ? sonarrModalElement.getAttribute('data-is-new-series') === 'true' : false;
            const mediaIdSelected = document.getElementById('sonarrSelectedSeriesId').value;

            if (!mediaIdSelected) {
                mapButton.disabled = true;
                return;
            }

            if (isNew) {
                const rootFolderSelected = document.getElementById('sonarrRootFolderSelect').value;
                const qualityProfileSelected = document.getElementById('sonarrQualityProfileSelect').value;
                mapButton.disabled = !(rootFolderSelected && qualityProfileSelected);
            } else {
                mapButton.disabled = false; // Pour une série existante, l'ID suffit
            }
        }
        // --- FIN NOUVELLES FONCTIONS ---
        // ==================================================================================
        // FIN DE LA NOUVELLE FONCTION HELPER
        // ==================================================================================
        // ==================================================================================
        // FIN DES NOUVELLES FONCTIONS JS
        // ==================================================================================
        async function executeSonarrSearch() {
            const query = document.getElementById('sonarrSearchQuery').value;
            const resultsDiv = document.getElementById('sonarrSearchResults');

            if (!query.trim()) {
                if(resultsDiv) resultsDiv.innerHTML = '<p class="text-warning">Terme de recherche manquant.</p>';
                return;
            }
            if(resultsDiv) resultsDiv.innerHTML = `<div class="d-flex align-items-center"><strong role="status">Recherche Sonarr...</strong><div class="spinner-border ms-auto"></div></div>`;

            try {
                const response = await fetch(`{{ url_for('seedbox_ui.search_sonarr_api') }}?query=${encodeURIComponent(query)}`);
                if (!response.ok) {
                    let eD; try{eD=await response.json()}catch(e){eD={error:"Erreur serveur."}}
                    throw new Error(eD.error||`HTTP ${response.status}`);
                }
                const results = await response.json();

                if (!resultsDiv) {
                    console.error("Div 'sonarrSearchResults' non trouvée.");
                    return;
                }

                if (results.length > 0) {
                    console.log("Premier résultat brut de l'API Sonarr (/lookup) pour \"" + results[0].title + "\":", JSON.stringify(results[0], null, 2));
                } else {
                    console.log("Aucun résultat retourné par l'API Sonarr (/lookup).");
                }

                if (results.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-muted">Aucune série trouvée.</p>';
                    return;
                }
                let html = '<ul class="list-group mt-3">';
                results.forEach(series => {
                    // alert(`Processing series in forEach: ${series.title} - TVDB ID: ${series.tvdbId} - Sonarr ID: ${series.id}`); // Commentez ou supprimez après débogage

                    let posterUrl = series.remotePoster || (series.images && series.images.length > 0 ? series.images.find(img => img.coverType === 'poster')?.remoteUrl : 'https://via.placeholder.com/60x90?text=N/A');
                    if (!posterUrl) { posterUrl = 'https://via.placeholder.com/60x90?text=N/A';}
                    const escapedSeriesTitle = escapeJsString(series.title); // Assurez-vous que escapeJsString est bien définie

                    const sonarrIdAsInt = parseInt(series.id); // Convertir en entier pour une comparaison fiable
                    const isAlreadyInSonarr = !isNaN(sonarrIdAsInt) && sonarrIdAsInt > 0;
                    const idForHandler = isAlreadyInSonarr ? sonarrIdAsInt : (parseInt(series.tvdbId) || 0); // Assurer que tvdbId est aussi un nombre ou 0

                    console.log(
                        `Traitement série: "${series.title}"\n` +
                        `  - series.id (raw): ${series.id}, series.tvdbId (raw): ${series.tvdbId}\n` +
                        `  - isAlreadyInSonarr (calculé): ${isAlreadyInSonarr}\n` +
                        `  - idForHandler (utilisé pour le bouton): ${idForHandler}`
                    );

                    let buttonText = "";
                    let buttonIcon = "";
                    let buttonClass = "btn-success";
                    let buttonTitle = "";
                    let disabledReason = "ID externe/interne manquant ou invalide";

                    if (isAlreadyInSonarr) {
                        buttonText = "Sélectionner";
                        buttonIcon = "fas fa-check-circle";
                        buttonTitle = `Mapper à la série existante : ${series.title}`;
                    } else {
                        buttonText = "Ajouter & Sélectionner";
                        buttonIcon = "fas fa-plus-circle";
                        buttonClass = "btn-info";
                        buttonTitle = `Ajouter la série '${series.title}' à Sonarr et la sélectionner`;
                        if (!idForHandler) { // Si tvdbId est manquant pour une nouvelle série
                            disabledReason = "TVDB ID manquant pour ajouter cette nouvelle série";
                        }
                    }

                    // MODIFIÉ : Conversion explicite de isAlreadyInSonarr en chaîne pour l'attribut onclick
                    const isAddedStringForOnclick = isAlreadyInSonarr ? 'true' : 'false';
                    let onclickAction = `handleGenericSonarrSeriesSelection(${idForHandler || 0}, '${escapedSeriesTitle}', ${isAddedStringForOnclick})`;

                    html += `
                        <li class="list-group-item"><div class="row align-items-center">
                            <div class="col-auto"><img src="${posterUrl}" alt="${escapedSeriesTitle}" class="img-fluid rounded" style="max-height: 90px;" onerror="this.onerror=null; this.src='https://via.placeholder.com/60x90?text=ImgErr';"></div>
                            <div class="col">
                                <strong>${series.title}</strong> (${series.year||'N/A'})<br>
                                <small class="text-muted">
                                    Statut: <span class="fw-bold ${isAlreadyInSonarr ? 'text-success' : 'text-primary'}">${isAlreadyInSonarr ? (series.status || 'Gérée') : 'Non Ajoutée'}</span>
                                    | TVDB ID: ${series.tvdbId||'N/A'}
                                    ${isAlreadyInSonarr && series.id ? `| Sonarr ID: ${series.id}` : ''}
                                </small>
                                <p class="mb-0 small">${(series.overview||'').substring(0,120)}${(series.overview||'').length>120?'...':''}</p>
                            </div>
                            <div class="col-auto">
                                <button type="button" class="btn ${buttonClass} btn-sm" onclick="${onclickAction}" title="${buttonTitle}" ${idForHandler ? '' : `disabled title="${disabledReason}"`}>
                                    <i class="${buttonIcon}"></i> ${buttonText}
                                </button>
                            </div>
                        </div></li>`;
                });
                html += '</ul>';
                resultsDiv.innerHTML = html;
            } catch (error) {
                if(resultsDiv) resultsDiv.innerHTML = `<p class="text-danger">Erreur recherche Sonarr: ${error.message}</p>`;
                console.error("Erreur executeSonarrSearch:", error);
            }
        }

     async function executeRadarrSearch() {
         const query = document.getElementById('radarrSearchQuery').value; // ID de l'input de recherche Radarr
         const resultsDiv = document.getElementById('radarrSearchResults'); // ID de la div pour les résultats Radarr

         if (!query.trim()) {
             if(resultsDiv) resultsDiv.innerHTML = '<p class="text-warning">Terme de recherche manquant.</p>';
             return;
         }
         if(resultsDiv) resultsDiv.innerHTML = `<div class="d-flex align-items-center"><strong role="status">Recherche Radarr...</strong><div class="spinner-border ms-auto"></div></div>`;

         try {
             const response = await fetch(`{{ url_for('seedbox_ui.search_radarr_api') }}?query=${encodeURIComponent(query)}`);
             if (!response.ok) {
                 let eD; try{eD=await response.json()}catch(e){eD={error:"Erreur serveur Radarr."}}
                 throw new Error(eD.error||`HTTP ${response.status}`);
             }
             const results = await response.json();

             if (!resultsDiv) {
                 console.error("Div 'radarrSearchResults' non trouvée.");
                 return;
             }

             if (results.length === 0) {
                 resultsDiv.innerHTML = '<p class="text-muted">Aucun film trouvé.</p>';
                 return;
             }
             let html = '<ul class="list-group mt-3">';
             results.forEach(movie => {
                 let posterUrl = movie.remotePoster || (movie.images && movie.images.length > 0 ? movie.images.find(img => img.coverType === 'poster')?.remoteUrl : 'https://via.placeholder.com/60x90?text=N/A');
                 if (!posterUrl) { posterUrl = 'https://via.placeholder.com/60x90?text=N/A'; }
                 const escapedMovieTitle = escapeJsString(movie.title);

                 // L'action onclick appelle handleGenericRadarrMovieSelection
                 let onclickAction = `handleGenericRadarrMovieSelection(${movie.id || 0}, '${escapedMovieTitle}')`;

                 html += `
                     <li class="list-group-item"><div class="row align-items-center">
                         <div class="col-auto"><img src="${posterUrl}" alt="Poster pour ${escapedMovieTitle}" class="img-fluid rounded" style="max-height: 90px;" onerror="this.onerror=null; this.src='https://via.placeholder.com/60x90?text=ImgErr';"></div>
                         <div class="col"><strong>${movie.title}</strong> (${movie.year||'N/A'})<br><small class="text-muted">Statut: ${movie.status||'N/A'} | TMDB ID: ${movie.tmdbId||'N/A'}</small><p class="mb-0 small">${(movie.overview||'').substring(0,120)}${(movie.overview||'').length>120?'...':''}</p></div>
                         <div class="col-auto"><button class="btn btn-success btn-sm" onclick="${onclickAction}" ${movie.id?'':'disabled title="Film non géré."'}><i class="fas fa-check-circle"></i> Sélectionner</button></div>
                     </div></li>`;
             });
             html += '</ul>';
             resultsDiv.innerHTML = html;
         } catch (error) {
             if(resultsDiv) resultsDiv.innerHTML = `<p class="text-danger">Erreur recherche Radarr: ${error.message}</p>`;
             console.error("Erreur executeRadarrSearch:", error);
         }
     }

     // --- NOUVELLE FONCTION HELPER pour la sélection générique dans le modal RADARR ---
    function handleGenericRadarrMovieSelection(movieId, movieTitle) { // movieTitle est déjà échappé
        const selectedMovieIdInput = document.getElementById('radarrSelectedMovieId');
        const selectedMovieTitleDisplay = document.getElementById('radarrSelectedMovieTitle');

        if (selectedMovieIdInput) selectedMovieIdInput.value = movieId;
        if (selectedMovieTitleDisplay) selectedMovieTitleDisplay.innerText = `Film sélectionné : ${movieTitle}`;

        const modalMapButton = document.getElementById('radarrModalMapButton');
        if (modalMapButton) {
            modalMapButton.disabled = !movieId;
        }
        const resultsDiv = document.getElementById('radarrSearchResults');
        if(resultsDiv) {
            resultsDiv.innerHTML = `<p class="alert alert-info mt-2">Film sélectionné : <strong>${movieTitle}</strong> (ID: ${movieId}).<br>Cliquez sur le bouton "Mapper..." en bas du modal.</p>`;
        }
    }
    // --- NOUVELLE FONCTION HELPER pour la sélection générique dans le modal SONARR ---
    // (Utilisée par sonarrSearchModal pour le mapping depuis staging, items problématiques, ou batch premap seedbox)
        function handleGenericSonarrSeriesSelection(mediaId, seriesTitle, isAddedBoolean) { // Renommé pour clarté
            // isAddedBoolean est maintenant un vrai booléen true/false

            console.log(`handleGenericSonarrSeriesSelection: mediaId=${mediaId}, title=${seriesTitle}, isAdded=${isAddedBoolean}`);

            // Éléments communs aux modals de recherche Sonarr
            const selectedSeriesIdInput = document.getElementById('sonarrSelectedSeriesId'); // Dans sonarrSearchModal
            const selectedSeriesTitleDisplay = document.getElementById('sonarrSelectedSeriesTitle'); // Dans sonarrSearchModal
            const modalMapButton = document.getElementById('sonarrModalMapButton'); // Bouton principal de sonarrSearchModal
            const searchResultsDiv = document.getElementById('sonarrSearchResults'); // Dans sonarrSearchModal
            const sonarrModalElement = document.getElementById('sonarrSearchModal'); // L'élément du modal sonarrSearchModal

            // Éléments spécifiques au modal addTorrentModal
            const addTorrentSelectedSeriesIdInput = document.getElementById('addTorrentTargetId'); // Input pour l'ID dans addTorrentModal
            const addTorrentSelectedMediaDisplay = document.getElementById('addTorrentSelectedMediaDisplay'); // Pour afficher le nom dans addTorrentModal
            const addTorrentModalElement = document.getElementById('addTorrentModal'); // L'élément du modal addTorrentModal
            const addTorrentSonarrOptionsDiv = document.getElementById('addTorrentSonarrNewSeriesOptions'); // Options dans addTorrentModal

            // Déterminer quel modal est actif ou concerné (simpliste, basé sur celui qui a appelé la recherche)
            // On pourrait passer le contexte en argument si c'était plus complexe.
            // Pour l'instant, on met à jour les deux s'ils existent, ou on cible en fonction du contexte d'appel.
            // Le plus simple est de savoir quel modal a initié la recherche.
            // Supposons que executeSonarrSearch est pour sonarrSearchModal,
            // et executeArrSearchForAddTorrentModal est pour addTorrentModal.

            // Mise à jour des champs pour le modal qui a probablement initié la recherche
            // Si on est dans le contexte de addTorrentModal (currentAddTorrentAppType serait défini)
            if (typeof currentAddTorrentAppType !== 'undefined' && currentAddTorrentAppType === 'sonarr') {
                if (addTorrentSelectedSeriesIdInput) addTorrentSelectedSeriesIdInput.value = mediaId;
                if (addTorrentSelectedMediaDisplay) addTorrentSelectedMediaDisplay.innerHTML = `Série : <strong>${seriesTitle}</strong> (ID: ${mediaId})`;
                if (addTorrentModalElement) {
                    addTorrentModalElement.setAttribute('data-selected-is-new', !isAddedBoolean ? 'true' : 'false');
                    addTorrentModalElement.setAttribute('data-selected-media-id', mediaId);
                    addTorrentModalElement.setAttribute('data-selected-media-title', seriesTitle);
                    addTorrentModalElement.setAttribute('data-selected-media-type', 'sonarr');
                }
                // Activer le bouton principal de addTorrentModal
                const submitAddTorrentBtn = document.getElementById('submitAddTorrentBtn');
                if (submitAddTorrentBtn) submitAddTorrentBtn.disabled = !mediaId;

                // Afficher les options d'ajout si c'est une nouvelle série DANS addTorrentModal
                if (addTorrentSonarrOptionsDiv) {
                    if (!isAddedBoolean) {
                        addTorrentSonarrOptionsDiv.style.display = 'block';
                        populateSelectFromServer("{{ url_for('seedbox_ui.get_sonarr_rootfolders_api') }}", 'sonarrRootFolderSelectForAdd', 'path', 'path', 'Dossier Racine Sonarr');
                        populateSelectFromServer("{{ url_for('seedbox_ui.get_sonarr_qualityprofiles_api') }}", 'sonarrQualityProfileSelectForAdd', 'id', 'name', 'Profil Qualité Sonarr');
                    } else {
                        addTorrentSonarrOptionsDiv.style.display = 'none';
                    }
                }
                 if(document.getElementById('torrentSonarrSearchResults')) document.getElementById('torrentSonarrSearchResults').innerHTML = `<p class="alert alert-info mt-2">Série sélectionnée : <strong>${seriesTitle}</strong>. Prêt à continuer.</p>`;


            } else { // Contexte de sonarrSearchModal (staging local, items problématiques, etc.)
                if (selectedSeriesIdInput) selectedSeriesIdInput.value = mediaId;
                if (selectedSeriesTitleDisplay) selectedSeriesTitleDisplay.innerText = `Série sélectionnée : ${seriesTitle}`;
                currentlySelectedSonarrSeriesIdInModal = mediaId;

                if (sonarrModalElement) {
                    sonarrModalElement.setAttribute('data-selected-is-new', !isAddedBoolean ? 'true' : 'false');
                    sonarrModalElement.setAttribute('data-selected-media-id', mediaId);
                    sonarrModalElement.setAttribute('data-selected-media-title', seriesTitle);
                }

                if (modalMapButton) { // sonarrModalMapButton
                    modalMapButton.disabled = !mediaId;
                    // Le texte du bouton est déjà géré par la fonction qui a ouvert sonarrSearchModal
                    // On ajuste juste la classe si c'est un "ajout" (ce qui ne devrait pas arriver pour ce modal pour l'instant)
                    if (!isAddedBoolean) {
                        modalMapButton.classList.remove('btn-primary');
                        modalMapButton.classList.add('btn-info');
                        // Normalement, sonarrSearchModal ne devrait pas gérer l'ajout de nouvelles séries.
                        // Si on voulait le permettre, il faudrait aussi lui ajouter les selects RootFolder/QualityProfile.
                    } else {
                        modalMapButton.classList.remove('btn-info');
                        modalMapButton.classList.add('btn-primary');
                    }
                }

                if(resultsDiv) { // sonarrSearchResults
                    resultsDiv.innerHTML = `<p class="alert alert-info mt-2">Série sélectionnée : <strong>${seriesTitle}</strong> (ID: ${mediaId}).<br>
                        ${isAddedBoolean ? 'Cette série est déjà gérée par Sonarr.' : 'Cette série devrait être ajoutée (fonctionnalité non active pour ce dialogue).'}<br>
                        Cliquez sur le bouton d'action en bas du modal.</p>`;
                }

                const manualSeasonDiv = document.getElementById('sonarrManualSeasonDiv');
                if (manualSeasonDiv && sonarrModalElement) {
                    const currentAction = sonarrModalElement.getAttribute('data-current-action');
                    if (isAddedBoolean && (currentAction === 'mapIndividualStaging' || currentAction === 'mapProblemItem' || currentAction === 'sftpRetrieveAndMapIndividual')) {
                        manualSeasonDiv.style.display = 'block';
                    } else {
                        manualSeasonDiv.style.display = 'none';
                    }
                }
            }
            // Activer le bouton de soumission du modal principal "Ajouter Torrent" si on est dans ce contexte
            // et que toutes les conditions sont remplies (y compris les selects pour nouvelle série)
            if (typeof currentAddTorrentAppType !== 'undefined' && currentAddTorrentAppType === 'sonarr') {
                 checkAndEnableAddTorrentSubmitButtonState();
            }
        }
     // MODIFIEZ votre fonction openRadarrSearchModal (pour mapping individuel depuis staging)
     function openRadarrSearchModal(itemPathForAction, itemType) {
         const itemNameForDisplay = itemPathForAction.split(/[\\/]/).pop();
         document.getElementById('radarrItemToMap').textContent = itemNameForDisplay;
         document.getElementById('radarrOriginalItemName').value = itemPathForAction;
         document.getElementById('radarrOriginalItemType').value = itemType;
         document.getElementById('radarrItemType').textContent = itemType === 'directory' ? 'Dossier (Staging)' : 'Fichier (Staging)';

         const searchQueryInput = document.getElementById('radarrSearchQuery');
         if (searchQueryInput) searchQueryInput.value = getCleanedSearchTerm(itemPathForAction);

         const searchResultsDiv = document.getElementById('radarrSearchResults');
         if (searchResultsDiv) searchResultsDiv.innerHTML = '';

         document.getElementById('radarrSelectedMovieId').value = '';
         document.getElementById('radarrSelectedMovieTitle').innerText = 'Aucun film sélectionné';

         const modalMapButton = document.getElementById('radarrModalMapButton');
         if (modalMapButton) {
             modalMapButton.innerHTML = '<i class="fas fa-link"></i> Mapper à ce Film';
             modalMapButton.disabled = true;
             modalMapButton.onclick = function() {
                 const movieId = document.getElementById('radarrSelectedMovieId').value;
                 if (movieId) {
                     triggerRadarrManualImport(movieId); // Appelle votre fonction de soumission pour Radarr
                 } else {
                     alert("Veuillez sélectionner un film.");
                 }
             };
         }

         var radarrModal = new bootstrap.Modal(document.getElementById('radarrSearchModal'));
         radarrModal.show();
     }

     // Votre fonction triggerRadarrManualImport (appelée par le mapping individuel depuis le staging)
     async function triggerRadarrManualImport(radarrMovieId) {
         // ... (votre code existant, mais assurez-vous qu'il récupère problem_torrent_hash si le modal est réutilisé)
         const originalItemName = document.getElementById('radarrOriginalItemName').value;
         const movieTitleForDisplay = document.getElementById('radarrSelectedMovieTitle').innerText.replace('Film sélectionné : ', '');
         const resultsDiv = document.getElementById('radarrSearchResults');
         if(resultsDiv) resultsDiv.innerHTML = `<div class="alert alert-info">Tentative d'import pour '${escapeJsString(originalItemName.split(/[\\/]/).pop())}' vers '${escapeJsString(movieTitleForDisplay)}'...</div>`;

         const radarrModalElement = document.getElementById('radarrSearchModal');
         const problemTorrentHash = radarrModalElement ? radarrModalElement.getAttribute('data-problem-torrent-hash') : null;

         const payload = { item_name: originalItemName, movie_id: parseInt(radarrMovieId) };
         if (problemTorrentHash && problemTorrentHash !== '') {
             payload.problem_torrent_hash = problemTorrentHash;
         }

         const modalMapButton = document.getElementById('radarrModalMapButton');
         if(modalMapButton) modalMapButton.disabled = true;
         // ... (reste de votre fetch vers seedbox_ui.trigger_radarr_import et gestion de la réponse)
          try {
             const response = await fetch(`{{ url_for('seedbox_ui.trigger_radarr_import') }}`, { /* ... */ body: JSON.stringify(payload) });
             const result = await response.json();
             if (response.ok && result.success) {
                 // ... (succès)
                 flashMessageGlobally(result.message || `Import pour '${escapeJsString(originalItemName.split(/[\\/]/).pop())}' réussi.`, 'success');
                  setTimeout(() => { /* ... reload ... */ }, 2500);
             } else {
                 throw new Error(result.error || "Erreur inconnue (import Radarr).");
             }
         } catch (error) {
             // ... (erreur)
              flashMessageGlobally(`Erreur d'import Radarr: ${escapeJsString(error.message)}`, 'danger');
         } finally {
             if(modalMapButton) modalMapButton.disabled = false;
         }
     }
        async function triggerSonarrManualImportWithSeason(
            mediaIdFromSelection, // Peut être Sonarr ID (si existant) ou TVDB ID (si nouveau)
            seriesTitleForDisplay, // Titre pour les messages, déjà échappé
            userForcedSeason
            // problem_torrent_hash est déjà géré dans le payload en le lisant du modal
        ) {
            const originalItemName = document.getElementById('sonarrOriginalItemName').value; // item_name_in_staging
            const resultsDiv = document.getElementById('sonarrSearchResults');
            const sonarrModalElement = document.getElementById('sonarrSearchModal'); // L'élément du modal

            if (!mediaIdFromSelection && mediaIdFromSelection !== 0) { // mediaId peut être 0 si non trouvé par lookup mais on veut quand même essayer
                alert("Aucun ID de série valide fourni.");
                return;
            }
            if(resultsDiv) resultsDiv.innerHTML = `<div class="alert alert-info">Préparation de l'import pour '${escapeJsString(originalItemName.split(/[\\/]/).pop())}' vers la série '${seriesTitleForDisplay}'...</div>`;

            // --- NOUVEAU : Lire les attributs data- du modal ---
            const isNewSeries = sonarrModalElement ? sonarrModalElement.getAttribute('data-is-new-series') === 'true' : false;
            // mediaIdForPayload est l'ID qui sera pertinent pour le backend (Sonarr ID ou TVDB ID)
            const mediaIdForPayload = sonarrModalElement ? sonarrModalElement.getAttribute('data-selected-media-id') : mediaIdFromSelection; // Fallback sur l'argument
            // mediaTitleForAdd est le titre à utiliser si on ajoute la série
            const mediaTitleForAdd = sonarrModalElement ? sonarrModalElement.getAttribute('data-selected-media-title') : seriesTitleForDisplay; // Fallback

            const problemTorrentHash = sonarrModalElement ? sonarrModalElement.getAttribute('data-problem-torrent-hash') : null;
            // --- FIN NOUVEAU ---

            const payload = {
                item_name: originalItemName,
                is_new_series: isNewSeries, // Indiquer au backend si c'est un ajout
                problem_torrent_hash: (problemTorrentHash && problemTorrentHash !== '') ? problemTorrentHash : undefined
            };

            if (isNewSeries) {
                payload.tvdb_id = parseInt(mediaIdForPayload); // Si nouvelle, mediaIdForPayload est le tvdbId
                payload.series_title_for_add = mediaTitleForAdd; // Le titre à utiliser pour l'ajout
                // IMPORTANT: Il faudra ajouter le root_folder_path et quality_profile_id au payload si isNewSeries
                // Pour l'instant, on omet, mais le backend devra les demander ou utiliser des défauts.
                // payload.root_folder_path = document.getElementById('ID_DE_VOTRE_SELECTEUR_ROOTFOLDER_SONARR').value;
                // payload.quality_profile_id = document.getElementById('ID_DE_VOTRE_SELECTEUR_QUALITYPROFILE_SONARR').value;
                console.log("Préparation pour AJOUTER et mapper nouvelle série:", payload);
            } else {
                payload.series_id = parseInt(mediaIdForPayload); // Si existante, mediaIdForPayload est l'ID interne Sonarr
                console.log("Préparation pour MAPPER série existante:", payload);
            }

            if (userForcedSeason && userForcedSeason.trim() !== '') {
                payload.user_forced_season = parseInt(userForcedSeason);
            }

            const modalMapButton = document.getElementById('sonarrModalMapButton');
            if(modalMapButton) modalMapButton.disabled = true;

            try {
                // La route backend '/trigger-sonarr-import' devra être adaptée pour gérer 'is_new_series', 'tvdb_id', etc.
                const response = await fetch(`{{ url_for('seedbox_ui.trigger_sonarr_import') }}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (!response.ok && !(response.status === 200 && result.action_required)) {
                    throw new Error(result.error || `Erreur HTTP: ${response.status}`);
                }

                if (result.success === true) {
                    if(resultsDiv) resultsDiv.innerHTML = `<div class="alert alert-success">${escapeJsString(result.message) || 'Importation/Ajout initié.'}</div>`;
                    flashMessageGlobally(result.message || `Action pour '${escapeJsString(originalItemName.split(/[\\/]/).pop())}' (série: ${seriesTitleForDisplay}) initiée.`, 'success');
                    setTimeout(() => {
                        const modalInstance = bootstrap.Modal.getInstance(sonarrModalElement);
                        if (modalInstance) modalInstance.hide();
                        window.location.reload();
                    }, 2500);
                } else if (result.action_required === "resolve_season_episode_mismatch") {
                    const d = result.details;
                    // Assurer que problem_torrent_hash est propagé si c'était un re-mapping
                    const problemHashForMismatch = d.problem_torrent_hash || payload.problem_torrent_hash;
                    // ... (votre logique existante pour afficher le modal de discordance S/E) ...
                    // ... en s'assurant que problemHashForMismatch est passé à forceSonarrImport ...
                    let html = `<div class="alert alert-warning">...`; // Votre HTML pour discordance
                    // Assurez-vous que les appels à forceSonarrImport dans ce HTML incluent bien problemHashForMismatch
                    // Exemple: onclick="forceSonarrImport('...', '${problemHashForMismatch || ''}')"
                    if(resultsDiv) resultsDiv.innerHTML = html;
                } else {
                    throw new Error(result.error || "Erreur inconnue (import/ajout).");
                }
            } catch (error) {
                if(resultsDiv) resultsDiv.innerHTML = `<div class="alert alert-danger">${escapeJsString(error.message)}</div>`;
                console.error("Erreur triggerSonarrManualImportWithSeason:", error);
                flashMessageGlobally(`Erreur d'action Sonarr: ${escapeJsString(error.message)}`, 'danger');
            } finally {
                if(modalMapButton) modalMapButton.disabled = false;
            }
        }

        async function forceSonarrImport(stagingItemName, seriesId, strategy, targetSeason, targetEpisode, seriesTitleForDisplay) { // seriesTitleForDisplay est déjà échappé
            const resultsDiv = document.getElementById('sonarrSearchResults');
            resultsDiv.innerHTML = `<div class="alert alert-info">Import forcé pour '${escapeJsString(stagingItemName.split(/[\\/]/).pop())}' vers '${seriesTitleForDisplay}' (S${targetSeason}E${targetEpisode}) stratégie '${strategy}'...</div>`;
            try {
                const response = await fetch(`{{ url_for('seedbox_ui.force_sonarr_import_action') }}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_name: stagingItemName, series_id: seriesId, target_season: targetSeason, target_episode: targetEpisode })
                });
                const result = await response.json();
                if (response.ok && result.success) {
                    resultsDiv.innerHTML = `<div class="alert alert-success alert-dismissible fade show" role="alert">Import forcé: ${escapeJsString(result.message) || 'Réussi.'}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>`;
                    flashMessageGlobally(result.message || "Importation forcée réussie.", 'success');
                    setTimeout(() => { bootstrap.Modal.getInstance(document.getElementById('sonarrSearchModal'))?.hide(); window.location.reload(); }, 3000);
                } else { throw new Error(result.error || "Erreur inconnue (import forcé)."); }
            } catch (error) {
                resultsDiv.innerHTML = `<div class="alert alert-danger alert-dismissible fade show" role="alert">Erreur import forcé: ${escapeJsString(error.message)}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>`;
                console.error("Erreur forceSonarrImport:", error);
            }
        }

async function triggerRadarrManualImport(radarrMovieId, movieTitle) { // movieTitle ici est déjà échappé
            const originalItemPathForAction = document.getElementById('radarrOriginalItemName').value; // Ceci est item_name_in_staging
            const resultsDiv = document.getElementById('radarrSearchResults'); // Div pour afficher les messages DANS le modal

            if (radarrMovieId === 0) { /* Gérer le cas où l'ID est 0 si nécessaire */ return; }

            resultsDiv.innerHTML = `<div class="alert alert-info">Tentative d'import de '${escapeJsString(originalItemPathForAction.split(/[\\/]/).pop())}' pour le film '${movieTitle}' (ID: ${radarrMovieId})...</div>`;

            // --- NOUVEAU: Récupérer le hash du torrent problématique si présent ---
            const radarrModalElement = document.getElementById('radarrSearchModal'); // << VÉRIFIEZ CET ID, est-ce le bon ID de votre modal Radarr ?
            let problemTorrentHash = null;
            if (radarrModalElement) {
                problemTorrentHash = radarrModalElement.getAttribute('data-problem-torrent-hash');
            }
            // --- FIN NOUVEAU ---

            const payload = {
                item_name: originalItemPathForAction,
                movie_id: radarrMovieId
            };

            // Ajouter le hash au payload s'il existe (indique un re-mapping)
            if (problemTorrentHash && problemTorrentHash !== '') {
                payload.problem_torrent_hash = problemTorrentHash;
                console.log("Re-mapping item problématique (Radarr) avec hash:", problemTorrentHash);
            }

            try {
                const response = await fetch(`{{ url_for('seedbox_ui.trigger_radarr_import') }}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload) // Envoi du payload mis à jour
                });
                const result = await response.json(); // Toujours essayer de parser

                if (response.ok && result.success) { // response.ok vérifie les statuts 200-299
                    resultsDiv.innerHTML = `<div class="alert alert-success alert-dismissible fade show" role="alert">Importation pour '${escapeJsString(originalItemPathForAction.split(/[\\/]/).pop())}' vers '${movieTitle}' initiée. Message: ${result.message || ''}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>`;
                    flashMessageGlobally(result.message || `Import pour '${escapeJsString(originalItemPathForAction.split(/[\\/]/).pop())}' (film: ${movieTitle}) initié.`, 'success');

                    setTimeout(() => {
                        const modalInstance = bootstrap.Modal.getInstance(document.getElementById('radarrSearchModal')); // << VÉRIFIEZ CET ID
                        if (modalInstance) modalInstance.hide();
                        window.location.reload();
                    }, 2500);
                } else {
                    // Si response.ok est faux, ou si response.ok est vrai mais result.success est faux
                    throw new Error(result.error || `Erreur inconnue lors de l'import Radarr (HTTP ${response.status}).`);
                }
            } catch (error) {
                resultsDiv.innerHTML = `<div class="alert alert-danger alert-dismissible fade show" role="alert">Erreur importation Radarr: ${escapeJsString(error.message)}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>`;
                console.error("Erreur import Radarr:", error);
            }
        }

        function flashMessageGlobally(message, category) {
            const container=document.querySelector('div.container.mt-4');
            if(!container)return;
            const alertHtml=`<div class="alert alert-${category} alert-dismissible fade show" role="alert" style="margin-top: 1rem;">${message}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>`;
            const firstMajorElement = container.querySelector('header.border-bottom + h1, header.border-bottom + div.mb-3, header.border-bottom + p.text-muted');
            if(firstMajorElement){firstMajorElement.insertAdjacentHTML('afterend',alertHtml)}else{container.insertAdjacentHTML('afterbegin',alertHtml)}
            const newAlert = container.querySelector('.alert.alert-dismissible.show');
            if(newAlert)newAlert.scrollIntoView({behavior:'smooth',block:'center'});
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.file-tree .toggle-children').forEach(toggler => {
                toggler.addEventListener('click', function (event) {
                    event.preventDefault();
                    const childrenList = this.closest('li').querySelector('.children-list');
                    const icon = this.querySelector('i');
                    if (childrenList) {
                        if (childrenList.style.display === 'none' || childrenList.style.display === '') {
                            childrenList.style.display = 'block';
                            icon.classList.remove('fa-plus-square');
                            icon.classList.add('fa-minus-square');
                        } else {
                            childrenList.style.display = 'none';
                            icon.classList.remove('fa-minus-square');
                            icon.classList.add('fa-plus-square');
                        }
                    }
                });
            });
            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) { return new bootstrap.Tooltip(tooltipTriggerEl); });

            // Add Torrent Modal specific listeners
            const addTorrentModalEl = document.getElementById('addTorrentModal');
            if (addTorrentModalEl) {
                addTorrentModalEl.addEventListener('show.bs.modal', initializeAddTorrentModal);
            }
        });

        // --- Add Torrent Modal Logic ---
        let currentAddTorrentAppType = null; // 'sonarr' or 'radarr'

        function initializeAddTorrentModal() {
            console.log("INIT_MODAL: Début");

            const modalElement = document.getElementById('addTorrentModal');
            if (!modalElement) {
                console.error("INIT_MODAL_ERROR: Modal 'addTorrentModal' introuvable !");
                return;
            }

            const addTorrentForm = document.getElementById('addTorrentForm');
            if (addTorrentForm) {
                console.log("INIT_MODAL: 1. Avant form.reset()");
                addTorrentForm.reset();
            }

            const searchSection = document.getElementById('addTorrentArrSearchSection');
            if (searchSection) {
                console.log("INIT_MODAL: 2. Avant searchSection.style.display");
                searchSection.style.display = 'none';
            }

            const searchResults = document.getElementById('addTorrentArrSearchResults');
            if (searchResults) {
                console.log("INIT_MODAL: 3. Avant searchResults.innerHTML");
                searchResults.innerHTML = '';
            }

            const feedbackDiv = document.getElementById('addTorrentFeedback');
            if (feedbackDiv) {
                console.log("INIT_MODAL: 4. Avant feedbackDiv.innerHTML");
                feedbackDiv.innerHTML = '';
            }

            const selectedMediaDisplayElement = document.getElementById('addTorrentSelectedMediaDisplay'); // ID CORRECT
            if (selectedMediaDisplayElement) {
                selectedMediaDisplayElement.textContent = 'Aucun';
            } else {
                console.error("handleAddTorrentAppTypeChange: Élément 'addTorrentSelectedMediaDisplay' non trouvé !");
            }

            const targetIdInput = document.getElementById('addTorrentTargetId');
            if (targetIdInput) {
                console.log("INIT_MODAL: 6. Avant targetIdInput.value");
                targetIdInput.value = '';
            }

            const originalNameInput = document.getElementById('addTorrentOriginalName');
            if (originalNameInput) {
                console.log("INIT_MODAL: 7. Avant originalNameInput.value");
                originalNameInput.value = '';
            }

            currentAddTorrentAppType = null;

            const sonarrOptionsDiv = document.getElementById('addTorrentSonarrNewSeriesOptions');
            const radarrOptionsDiv = document.getElementById('addTorrentRadarrNewMovieOptions');
            if (sonarrOptionsDiv) {
                console.log("INIT_MODAL: 8. Avant sonarrOptionsDiv.style.display");
                sonarrOptionsDiv.style.display = 'none';
            }
            if (radarrOptionsDiv) {
                console.log("INIT_MODAL: 9. Avant radarrOptionsDiv.style.display");
                radarrOptionsDiv.style.display = 'none';
            }

            const sonarrRootS = document.getElementById('sonarrRootFolderSelectForAdd');
            const sonarrQualS = document.getElementById('sonarrQualityProfileSelectForAdd');
            const radarrRootS = document.getElementById('radarrRootFolderSelectForAdd');
            const radarrQualS = document.getElementById('radarrQualityProfileSelectForAdd');
            const radarrAvailS = document.getElementById('radarrMinimumAvailabilitySelectForAdd');

            console.log("INIT_MODAL: 10. Avant réinitialisation des selects");
            if(sonarrRootS) { sonarrRootS.innerHTML = '<option value="" selected disabled>Chargement...</option>'; sonarrRootS.disabled = true; }
            if(sonarrQualS) { sonarrQualS.innerHTML = '<option value="" selected disabled>Chargement...</option>'; sonarrQualS.disabled = true; }
            if(radarrRootS) { radarrRootS.innerHTML = '<option value="" selected disabled>Chargement...</option>'; radarrRootS.disabled = true; }
            if(radarrQualS) { radarrQualS.innerHTML = '<option value="" selected disabled>Chargement...</option>'; radarrQualS.disabled = true; }
            if(radarrAvailS) { radarrAvailS.value = 'announced'; radarrAvailS.disabled = true; }

            console.log("INIT_MODAL: 11. Avant attachement des listeners");
            // Listeners
            document.querySelectorAll('input[name="addTorrentAppType"]').forEach(radio => {
                radio.removeEventListener('change', handleAddTorrentAppTypeChange);
                radio.addEventListener('change', handleAddTorrentAppTypeChange);
            });

            const searchBtn = document.getElementById('addTorrentExecuteArrSearchBtn');
            if (searchBtn) {
                searchBtn.removeEventListener('click', executeArrSearchForAddTorrentModal);
                searchBtn.addEventListener('click', executeArrSearchForAddTorrentModal);
            }

            const fileUpload = document.getElementById('torrentFileUpload');
            if (fileUpload) {
                fileUpload.removeEventListener('change', handleTorrentFileChangeForAddTorrent);
                fileUpload.addEventListener('change', handleTorrentFileChangeForAddTorrent);
            }

            const magnetLinkInput = document.getElementById('torrentMagnetLink');
            if (magnetLinkInput) {
                magnetLinkInput.removeEventListener('input', handleMagnetLinkInputForAddTorrent);
                magnetLinkInput.addEventListener('input', handleMagnetLinkInputForAddTorrent);
            }

            const submitBtn = document.getElementById('submitAddTorrentBtn');
            if (submitBtn) {
                submitBtn.removeEventListener('click', handleSubmitAddTorrent);
                submitBtn.addEventListener('click', handleSubmitAddTorrent);
                console.log("INIT_MODAL: 12. Avant submitBtn.disabled");
                submitBtn.disabled = true;
            }

            if (modalElement) {
                console.log("INIT_MODAL: 13. Avant nettoyage des data-attributes");
                modalElement.removeAttribute('data-selected-is-new');
                modalElement.removeAttribute('data-selected-media-id');
                modalElement.removeAttribute('data-selected-media-title');
                modalElement.removeAttribute('data-selected-media-type');
            }
            console.log("INIT_MODAL: Fin");
        }

function handleAddTorrentAppTypeChange() {
            currentAddTorrentAppType = this.value;
            console.log("handleAddTorrentAppTypeChange: Nouveau type sélectionné:", currentAddTorrentAppType);

            const searchSection = document.getElementById('addTorrentArrSearchSection');
            if (searchSection) searchSection.style.display = 'block';
            else console.error("handleAddTorrentAppTypeChange: 'addTorrentArrSearchSection' non trouvé !");

            const searchResults = document.getElementById('addTorrentArrSearchResults');
            if (searchResults) searchResults.innerHTML = '';
            else console.error("handleAddTorrentAppTypeChange: 'addTorrentArrSearchResults' non trouvé !");

            const searchQuery = document.getElementById('addTorrentArrSearchQuery');
            if (searchQuery) searchQuery.value = '';
            else console.error("handleAddTorrentAppTypeChange: 'addTorrentArrSearchQuery' non trouvé !");

            // --- CORRECTION DE L'ID ICI ---
            const selectedMediaDisplayElement = document.getElementById('addTorrentSelectedMediaDisplay'); // ID CORRECT
            if (selectedMediaDisplayElement) {
                selectedMediaDisplayElement.textContent = 'Aucun';
                console.log("handleAddTorrentAppTypeChange: textContent de 'addTorrentSelectedMediaDisplay' mis à 'Aucun'.");
            } else {
                console.error("handleAddTorrentAppTypeChange: ERREUR - L'élément avec l'ID 'addTorrentSelectedMediaDisplay' est introuvable !");
            }
            // --- FIN CORRECTION ---

            const targetIdInput = document.getElementById('addTorrentTargetId');
            if (targetIdInput) targetIdInput.value = '';
            else console.error("handleAddTorrentAppTypeChange: 'addTorrentTargetId' non trouvé !");

            const queryPlaceholder = (currentAddTorrentAppType === 'sonarr') ? 'Nom de la série...' : 'Titre du film...';
            if (searchQuery) searchQuery.placeholder = queryPlaceholder; // searchQuery peut être null si non trouvé plus haut

            const sonarrOptionsDiv = document.getElementById('addTorrentSonarrNewSeriesOptions');
            const radarrOptionsDiv = document.getElementById('addTorrentRadarrNewMovieOptions');
            if (sonarrOptionsDiv) sonarrOptionsDiv.style.display = 'none';
            else console.error("handleAddTorrentAppTypeChange: 'addTorrentSonarrNewSeriesOptions' non trouvé !");

            if (radarrOptionsDiv) radarrOptionsDiv.style.display = 'none';
            else console.error("handleAddTorrentAppTypeChange: 'addTorrentRadarrNewMovieOptions' non trouvé !");

            const torrentFile = document.getElementById('torrentFileUpload').files[0];
            if (torrentFile && searchQuery) {
                searchQuery.value = getCleanedSearchTerm(torrentFile.name);
            }

            // Assurez-vous que updateSubmitAddTorrentButtonState est définie et appelée correctement
            if (typeof updateSubmitAddTorrentButtonState === "function") {
                updateSubmitAddTorrentButtonState();
            } else {
                console.error("handleAddTorrentAppTypeChange: La fonction updateSubmitAddTorrentButtonState n'est pas définie !");
            }
        }

        async function executeArrSearchForAddTorrentModal() {
            const query = document.getElementById('addTorrentArrSearchQuery').value;
            const resultsDivId = 'addTorrentArrSearchResults'; // ID de votre div unique pour les résultats
            const resultsDivElement = document.getElementById(resultsDivId);

            if (!currentAddTorrentAppType) {
                if(resultsDivElement) resultsDivElement.innerHTML = '<p class="text-warning">Veuillez d\'abord sélectionner Sonarr ou Radarr.</p>';
                return;
            }
            if (!query.trim()) {
                if(resultsDivElement) resultsDivElement.innerHTML = '<p class="text-warning">Terme de recherche manquant.</p>';
                return;
            }

            if(resultsDivElement) resultsDivElement.innerHTML = `<div class="d-flex align-items-center"><strong role="status">Recherche ${currentAddTorrentAppType}...</strong><div class="spinner-border ms-auto"></div></div>`;
            else {
                 console.error(`Élément avec ID '${resultsDivId}' non trouvé.`);
                 return;
            }

            const searchUrl = (currentAddTorrentAppType === 'sonarr') ?
                              `{{ url_for('seedbox_ui.search_sonarr_api') }}?query=${encodeURIComponent(query)}` :
                              `{{ url_for('seedbox_ui.search_radarr_api') }}?query=${encodeURIComponent(query)}`;
            try {
                const response = await fetch(searchUrl);
                if (!response.ok) {
                    let errorDetail = "Erreur de l'API de recherche.";
                    try { const errData = await response.json(); errorDetail = errData.error || errorDetail; } catch(e){}
                    throw new Error(errorDetail);
                }
                const results = await response.json();
                renderArrSearchResultsForAddTorrent(results, currentAddTorrentAppType, resultsDivId); // Passe l'ID
            } catch (error) {
                if(resultsDivElement) resultsDivElement.innerHTML = `<p class="text-danger">Erreur recherche: ${escapeJsString(error.message)}</p>`;
                console.error("Erreur recherche *Arr pour AddTorrentModal:", error);
            }
        }

        function handleTorrentFileChangeForAddTorrent(event) {
            if (event.target.files.length > 0) {
                 if(currentAddTorrentAppType) { // Only prefill if app type is already selected
                    document.getElementById('addTorrentArrSearchQuery').value = getCleanedSearchTerm(event.target.files[0].name);
                 }
                 document.getElementById('addTorrentOriginalName').value = event.target.files[0].name;
            } else {
                 document.getElementById('addTorrentOriginalName').value = '';
            }
        }

        function handleMagnetLinkInputForAddTorrent(event) {
            const magnetLink = event.target.value;
            const dnMatch = magnetLink.match(/&dn=([^&]+)/);
            if (dnMatch && dnMatch[1]) {
                 document.getElementById('addTorrentOriginalName').value = decodeURIComponent(dnMatch[1]).replace(/\+/g, ' ');
            } else {
                // Create a more unique fallback for originalName if magnet has no dn
                const timestamp = Date.now().toString().slice(-6); // last 6 digits of timestamp
                document.getElementById('addTorrentOriginalName').value = 'magnet_' + timestamp;
            }
        }

        async function handleSubmitAddTorrent() {
            const magnetLink = document.getElementById('torrentMagnetLink').value.trim();
            const torrentFile = document.getElementById('torrentFileUpload').files[0];
            // currentAddTorrentAppType est défini lorsque l'utilisateur choisit Sonarr/Radarr dans le modal
            const appType = currentAddTorrentAppType;
            // addTorrentTargetId stocke l'ID (interne *Arr ou externe TVDB/TMDB) sélectionné via selectArrItemForAddTorrent
            const mediaIdFromSelection = document.getElementById('addTorrentTargetId').value;
            let originalName = document.getElementById('addTorrentOriginalName').value.trim();
            const feedbackDiv = document.getElementById('addTorrentFeedback');
            const submitButton = document.getElementById('submitAddTorrentBtn'); // Référence au bouton

            feedbackDiv.innerHTML = '';

            if (!magnetLink && !torrentFile) { /* ... (vos validations existantes) ... */ return; }
            if (magnetLink && torrentFile) { /* ... */ return; }
            if (!appType) { /* ... */ return; }
            if (!mediaIdFromSelection) { // mediaIdFromSelection vient de la sélection dans la liste des résultats
                feedbackDiv.innerHTML = '<p class="text-danger">Veuillez rechercher et sélectionner une série ou un film cible.</p>'; return;
            }
            if (!originalName) { /* ... (votre logique de fallback pour originalName) ... */ return; }

            let torrentFileB64 = null;
            if (torrentFile) {
                try {
                    torrentFileB64 = await readFileAsBase64(torrentFile);
                } catch (e) {
                    feedbackDiv.innerHTML = '<p class="text-danger">Erreur lors de la lecture du fichier .torrent.</p>'; return;
                }
            }

            // --- NOUVEAU : Lire les attributs data- du modal pour le contexte d'ajout ---
            const addTorrentModalElement = document.getElementById('addTorrentModal');
            const isNewMedia = addTorrentModalElement.getAttribute('data-selected-is-new') === 'true';
            // mediaIdForPayload est l'ID pertinent (interne ou externe) stocké par selectArrItemForAddTorrent
            const mediaIdForPayload = addTorrentModalElement.getAttribute('data-selected-media-id');
            const mediaTitleForAdd = addTorrentModalElement.getAttribute('data-selected-media-title'); // Titre si nouveau
            // const selectedAppType = addTorrentModalElement.getAttribute('data-selected-media-type'); // Devrait correspondre à appType

            if (!mediaIdForPayload) { // Sécurité, devrait être défini par selectArrItemForAddTorrent
                 feedbackDiv.innerHTML = '<p class="text-danger">Erreur interne: ID du média sélectionné non trouvé.</p>'; return;
            }
            // --- FIN NOUVEAU ---

            const payload = {
                magnet_link: magnetLink || null,
                torrent_file_b64: torrentFileB64,
                app_type: appType, // 'sonarr' ou 'radarr'
                original_name: originalName, // Nom du fichier .torrent ou du magnet
                is_new_media: isNewMedia // Booléen
            };

            if (isNewMedia) {
                payload.external_id = parseInt(mediaIdForPayload); // C'est tvdbId ou tmdbId
                payload.title_for_add = mediaTitleForAdd; // Titre à utiliser pour l'ajout

                // Récupérer les valeurs des selects pour Root Folder et Quality Profile
                if (appType === 'sonarr') {
                    payload.root_folder_path = document.getElementById('sonarrRootFolderSelectForAdd').value;
                    payload.quality_profile_id = parseInt(document.getElementById('sonarrQualityProfileSelectForAdd').value);
                } else if (appType === 'radarr') {
                    payload.root_folder_path = document.getElementById('radarrRootFolderSelectForAdd').value;
                    payload.quality_profile_id = parseInt(document.getElementById('radarrQualityProfileSelectForAdd').value);
                }

                // Validation pour les nouvelles options
                if (!payload.root_folder_path) {
                    feedbackDiv.innerHTML = '<p class="text-danger">Veuillez sélectionner un Dossier Racine pour le nouveau média.</p>'; return;
                }
                if (!payload.quality_profile_id || isNaN(payload.quality_profile_id)) {
                    feedbackDiv.innerHTML = '<p class="text-danger">Veuillez sélectionner un Profil de Qualité pour le nouveau média.</p>'; return;
                }
            } else { // Média existant
                payload.target_id = parseInt(mediaIdForPayload); // C'est l'ID interne Sonarr/Radarr
            }

            console.log("Payload final pour /rtorrent_add_torrent_action:", payload);

            if(submitButton) submitButton.disabled = true; // Utiliser la variable du bouton
            feedbackDiv.innerHTML = '<p class="text-info">Ajout du torrent et pré-association en cours...</p>';

            try {
                // La route backend '/interaction/rtorrent/add' (rtorrent_add_torrent_action)
                // devra être adaptée pour gérer ce nouveau payload.
                const response = await fetch(`{{ url_for('seedbox_ui.rtorrent_add_torrent_action') }}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (response.ok && result.success) {
                    feedbackDiv.innerHTML = `<p class="alert alert-success">${escapeJsString(result.message)} (Hash: ${escapeJsString(result.torrent_hash || 'N/A')})</p>`;
                    setTimeout(() => {
                        const modalInstance = bootstrap.Modal.getInstance(addTorrentModalElement);
                        if (modalInstance) modalInstance.hide();
                        flashMessageGlobally(result.message || "Action pour le torrent terminée avec succès.", 'success');
                        // Recharger pour voir les changements dans pending_torrents_map ou la liste rTorrent
                        // window.location.reload(); // Décommentez si vous voulez un rechargement
                    }, 3000);
                } else {
                    throw new Error(result.error || `Erreur HTTP ${response.status}`);
                }
            } catch (error) {
                feedbackDiv.innerHTML = `<p class="alert alert-danger">Erreur: ${escapeJsString(error.message)}</p>`;
            } finally {
                if(submitButton) submitButton.disabled = false; // Utiliser la variable du bouton
            }
        }

        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        function renderArrSearchResultsForAddTorrent(results, appType, resultsDivId) {
            const resultsDiv = document.getElementById(resultsDivId);
            if (!resultsDiv) {
                console.error(`Div de résultats (ID: ${resultsDivId}) non trouvée.`);
                return;
            }

            if (!results || results.length === 0) {
                resultsDiv.innerHTML = `<p class="text-muted">Aucun ${appType === 'sonarr' ? 'série' : 'film'} trouvé.</p>`;
                return;
            }

            if (results.length > 0) {
                console.log(`Premier résultat brut de l'API ${appType} (/lookup) pour "${results[0].title}":`, JSON.stringify(results[0], null, 2));
            }

            let html = '<ul class="list-group mt-3 list-group-flush">';
            results.forEach(item => {
                const title = escapeJsString(item.title);
                const year = item.year || 'N/A';

                let posterUrl = item.remotePoster || (item.images && item.images.length > 0 ? item.images.find(img => img.coverType === 'poster')?.remoteUrl : null);
                if (!posterUrl) { posterUrl = 'https://via.placeholder.com/40x60?text=N/A'; }

                let isAlreadyAdded = false; // Initialiser
                let idForSelection = null;
                let idTypeForDisplay = "";
                let externalIdForDisplay = "";
                let sonarrRadarrInternalIdDisplay = "";
                let buttonText = "Choisir";
                let buttonIcon = "fas fa-check-circle";
                let buttonClass = "btn-success";
                let buttonTitle = "";

                if (appType === 'sonarr') {
                    const sonarrId = parseInt(item.id); // Essayer de convertir item.id en nombre
                    isAlreadyAdded = !isNaN(sonarrId) && sonarrId > 0; // Vrai si sonarrId est un nombre > 0
                    idForSelection = isAlreadyAdded ? sonarrId : item.tvdbId;
                    idTypeForDisplay = "TVDB ID";
                    externalIdForDisplay = item.tvdbId || 'N/A';
                    if (isAlreadyAdded && sonarrId) {
                        sonarrRadarrInternalIdDisplay = `| Sonarr ID: ${sonarrId}`;
                    }
                    // ... (logique pour buttonText, etc. pour Sonarr, comme vous l'avez)
                    if (isAlreadyAdded) {
                        buttonText = "Sélectionner";
                        buttonTitle = `Sélectionner la série existante : ${item.title}`;
                    } else {
                        buttonText = "Ajouter & Sélectionner";
                        buttonIcon = "fas fa-plus-circle";
                        buttonClass = "btn-info";
                        buttonTitle = `Ajouter la série '${item.title}' à Sonarr et la sélectionner`;
                    }
                } else if (appType === 'radarr') {
                    const radarrId = parseInt(item.id); // Essayer de convertir item.id en nombre
                    isAlreadyAdded = !isNaN(radarrId) && radarrId > 0; // Vrai si radarrId est un nombre > 0
                    idForSelection = isAlreadyAdded ? radarrId : item.tmdbId;
                    idTypeForDisplay = "TMDB ID";
                    externalIdForDisplay = item.tmdbId || 'N/A';
                     if (isAlreadyAdded && radarrId) {
                        sonarrRadarrInternalIdDisplay = `| Radarr ID: ${radarrId}`;
                    }
                    // ... (logique pour buttonText, etc. pour Radarr, comme vous l'avez)
                    if (isAlreadyAdded) {
                        buttonText = "Sélectionner";
                        buttonTitle = `Sélectionner le film existant : ${item.title}`;
                    } else {
                        buttonText = "Ajouter & Sélectionner";
                        buttonIcon = "fas fa-plus-circle";
                        buttonClass = "btn-info";
                        buttonTitle = `Ajouter le film '${item.title}' à Radarr et le sélectionner`;
                    }
                }

                console.log( // Log pour vérifier les valeurs finales avant de générer le bouton
                    `renderArr: Item='${item.title}', AppType='${appType}'\n` +
                    `  - item.id (raw): '${item.id}', item.tvdbId: '${item.tvdbId}', item.tmdbId: '${item.tmdbId}'\n` +
                    `  - isAlreadyAdded (booléen): ${isAlreadyAdded}\n` +
                    `  - idForSelection (utilisé pour bouton et onclick): ${idForSelection}`
                );

                const isAddedStringForOnclick = isAlreadyAdded ? 'true' : 'false';
                // Assurer que idForSelection est un nombre ou 0 pour l'onclick, et que title est bien échappé
                let onclickAction = `selectArrItemForAddTorrent(${idForSelection || 0}, '${title}', '${appType}', ${isAddedStringForOnclick})`;

                console.log(`renderArr: onclickAction STRING: ${onclickAction}`);

                html += `
                    <li class="list-group-item">
                        <div class="row align-items-center">
                            <div class="col-auto" style="width:50px;">
                                <img src="${posterUrl}" alt="Poster pour ${title}" class="img-fluid rounded"
                                     style="max-height: 60px;"
                                     onerror="this.onerror=null; this.src='https://via.placeholder.com/40x60?text=ImgErr';">
                            </div>
                            <div class="col">
                                <strong>${item.title}</strong> (${year})<br>
                                <small class="text-muted">
                                    Statut: <span class="fw-bold ${isAlreadyAdded ? 'text-success' : 'text-primary'}">${isAlreadyAdded ? (item.status || 'Géré(e)') : 'Non Ajouté(e)'}</span>
                                    | ${idTypeForDisplay}: ${externalIdForDisplay}
                                    ${sonarrRadarrInternalIdDisplay}
                                </small>
                            </div>
                            <div class="col-auto">
                                <button type="button" class="btn ${buttonClass} btn-sm"
                                        onclick="${onclickAction}"
                                        title="${buttonTitle}"
                                        ${idForSelection ? '' : 'disabled title="ID externe/interne manquant ou invalide"'} > {# Condition de désactivation #}
                                    <i class="${buttonIcon}"></i> ${buttonText}
                                </button>
                            </div>
                        </div>
                    </li>`;
            });
            html += '</ul>';
            resultsDiv.innerHTML = html;
        }
        // --- NOUVELLE FONCTION HELPER POUR PEUPLER LES SELECTS DEPUIS LE SERVEUR ---
        async function populateSelectFromServer(apiUrl, selectElementId, valueField, textField, selectTypeForLog) {
            const selectElement = document.getElementById(selectElementId);
            const defaultOptionText = `-- Choisir un ${selectTypeForLog} --`;

            if (!selectElement) {
                console.error(`Élément Select (ID: ${selectElementId}) non trouvé pour ${selectTypeForLog}.`);
                return;
            }
            console.log(`Peuplement de ${selectElementId} depuis ${apiUrl}`);
            selectElement.innerHTML = `<option value="">Chargement de ${selectTypeForLog.toLowerCase()}...</option>`;
            selectElement.disabled = true;

            const errorDivId = selectElementId.replace('SelectForAdd', 'ErrorForAdd'); // Assurez-vous que le remplacement est correct pour vos IDs d'erreur
            const errorElement = document.getElementById(errorDivId);
            if (errorElement) errorElement.textContent = '';

            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    let errorMsg = `Erreur HTTP ${response.status}`;
                    try {
                        const errData = await response.json();
                        errorMsg = errData.error || errorMsg;
                    } catch (e) { /* Pas de corps JSON ou erreur de parsing */ }
                    throw new Error(errorMsg);
                }
                const dataItems = await response.json();

                selectElement.innerHTML = `<option value="">${defaultOptionText}</option>`;
                if (dataItems && dataItems.length > 0) {
                    dataItems.forEach(item => {
                        selectElement.add(new Option(item[textField], item[valueField]));
                    });
                    selectElement.disabled = false;
                    // Attacher le listener seulement si le select est activé et a des options
                    selectElement.removeEventListener('change', updateSubmitAddTorrentButtonState);
                    selectElement.addEventListener('change', updateSubmitAddTorrentButtonState);
                } else {
                    selectElement.innerHTML = `<option value="">Aucun ${selectTypeForLog.toLowerCase()} trouvé</option>`;
                    // Le select reste disabled = true (défini plus haut)
                    if (errorElement) errorElement.textContent = `Aucun ${selectTypeForLog.toLowerCase()} disponible. Vérifiez la configuration de ${selectTypeForLog.split(' ')[0]}.`;
                }
            } catch (error) {
                console.error(`Erreur lors du chargement des ${selectTypeForLog.toLowerCase()}:`, error);
                selectElement.innerHTML = `<option value="">Erreur chargement</option>`;
                // Le select reste disabled = true
                if (errorElement) errorElement.textContent = `Erreur: ${error.message}`;
            } finally { // Assurer que l'état du bouton principal est mis à jour
                if (typeof updateSubmitAddTorrentButtonState === "function") {
                    updateSubmitAddTorrentButtonState();
                } else {
                    console.warn("updateSubmitAddTorrentButtonState n'est pas définie au moment de l'appel final de populateSelectFromServer");
                }
            }
        }
        // --- FIN NOUVELLE FONCTION HELPER ---
        function selectArrItemForAddTorrent(itemId, itemTitle, appType, isAddedString) {
            const isAdded = (String(isAddedString).toLowerCase() === 'true');
            console.log(`selectArrItemForAddTorrent: itemId=${itemId}, title=${itemTitle}, appType=${appType}, isAddedBoolean=${isAdded}`);

            document.getElementById('addTorrentTargetId').value = itemId;
            document.getElementById('addTorrentSelectedMediaDisplay').innerHTML = `${appType === 'sonarr' ? 'Série' : 'Film'}: <strong>${itemTitle}</strong> (ID: ${itemId})`;

            const addTorrentModalElement = document.getElementById('addTorrentModal');
            if (addTorrentModalElement) {
                addTorrentModalElement.setAttribute('data-selected-is-new', !isAdded ? 'true' : 'false');
                addTorrentModalElement.setAttribute('data-selected-media-id', itemId);
                addTorrentModalElement.setAttribute('data-selected-media-title', itemTitle);
                addTorrentModalElement.setAttribute('data-selected-media-type', appType);
                console.log("Attributs data- sur addTorrentModal:",
                            {
                                isNew: addTorrentModalElement.getAttribute('data-selected-is-new'),
                                mediaId: addTorrentModalElement.getAttribute('data-selected-media-id')
                            });
            }

            const resultsDivId = (appType === 'sonarr') ? 'torrentSonarrSearchResults' : 'torrentRadarrSearchResults';
            const resultsDiv = document.getElementById(resultsDivId);
            if (resultsDiv) {
                 resultsDiv.innerHTML = `<p class="alert alert-info mt-2"><strong>${itemTitle}</strong> sélectionné.<br>
                    ${isAdded ? 'Ce média est déjà géré.' : 'Ce média sera ajouté à ' + appType.charAt(0).toUpperCase() + appType.slice(1) + '.'}<br>
                    ${!isAdded ? 'Veuillez choisir les options d\'ajout ci-dessous.<br>' : ''}
                    Prêt à lancer le téléchargement et la pré-association.</p>`;
            }

            const sonarrOptionsDiv = document.getElementById('addTorrentSonarrNewSeriesOptions');
            const radarrOptionsDiv = document.getElementById('addTorrentRadarrNewMovieOptions');
            const sonarrRootSelect = document.getElementById('sonarrRootFolderSelectForAdd');
            const sonarrQualitySelect = document.getElementById('sonarrQualityProfileSelectForAdd');
            const radarrRootSelect = document.getElementById('radarrRootFolderSelectForAdd');
            const radarrQualitySelect = document.getElementById('radarrQualityProfileSelectForAdd');

            if (sonarrOptionsDiv) sonarrOptionsDiv.style.display = 'none';
            if (sonarrRootSelect) { sonarrRootSelect.disabled = true; sonarrRootSelect.innerHTML = '<option value="">--</option>'; }
            if (sonarrQualitySelect) { sonarrQualitySelect.disabled = true; sonarrQualitySelect.innerHTML = '<option value="">--</option>'; }
            if (radarrOptionsDiv) radarrOptionsDiv.style.display = 'none';
            if (radarrRootSelect) { radarrRootSelect.disabled = true; radarrRootSelect.innerHTML = '<option value="">--</option>'; }
            if (radarrQualitySelect) { radarrQualitySelect.disabled = true; radarrQualitySelect.innerHTML = '<option value="">--</option>'; }

            if (!isAdded) {
                if (appType === 'sonarr' && sonarrOptionsDiv) {
                    // ...
                } else if (appType === 'radarr' && radarrOptionsDiv) {
                    radarrOptionsDiv.style.display = 'block';
                    populateSelectFromServer("{{ url_for('seedbox_ui.get_radarr_rootfolders_api') }}", 'radarrRootFolderSelectForAdd', 'path', 'path', 'Dossier Racine Radarr');
                    populateSelectFromServer("{{ url_for('seedbox_ui.get_radarr_qualityprofiles_api') }}", 'radarrQualityProfileSelectForAdd', 'id', 'name', 'Profil Qualité Radarr');

                    // --- ACTIVER LE SELECT DE DISPONIBILITÉ ---
                    const radarrAvailS = document.getElementById('radarrMinimumAvailabilitySelectForAdd');
                    if (radarrAvailS) {
                        radarrAvailS.disabled = false;
                        // Ajouter un listener pour mettre à jour l'état du bouton de soumission quand il change
                        radarrAvailS.removeEventListener('change', updateSubmitAddTorrentButtonState); // Éviter duplication
                        radarrAvailS.addEventListener('change', updateSubmitAddTorrentButtonState);
                    }
                    // --- FIN ACTIVATION ---
                }
            }
            updateSubmitAddTorrentButtonState();
        }

        // --- NOUVELLE FONCTION pour gérer l'état du bouton submitAddTorrentBtn ---
        function updateSubmitAddTorrentButtonState() {
            const submitButton = document.getElementById('submitAddTorrentBtn');
            if (!submitButton) {
                console.warn("Bouton 'submitAddTorrentBtn' non trouvé pour la mise à jour de l'état.");
                return;
            }

            const addTorrentModalElement = document.getElementById('addTorrentModal');
            // S'assurer que l'élément modal existe avant de lire les attributs
            if (!addTorrentModalElement) {
                console.error("Élément 'addTorrentModal' non trouvé. Impossible de lire les attributs data-.");
                submitButton.disabled = true; // Sécurité : désactiver le bouton
                return;
            }

            const isNew = addTorrentModalElement.getAttribute('data-selected-is-new') === 'true';
            const mediaId = document.getElementById('addTorrentTargetId').value; // ID externe si nouveau, interne si existant
            const appType = currentAddTorrentAppType; // Variable globale mise à jour par le choix Sonarr/Radarr

            let allRequiredOptionsSelected = false; // Renommé pour plus de clarté

            if (mediaId) { // Un média doit avoir été sélectionné via la recherche
                if (isNew) { // Si c'est un nouveau média, vérifier les selects supplémentaires
                    let rootFolderSelected = false;
                    let qualityProfileSelected = false;

                    if (appType === 'sonarr') {
                        const rootSelect = document.getElementById('sonarrRootFolderSelectForAdd');
                        const qualitySelect = document.getElementById('sonarrQualityProfileSelectForAdd');

                        rootFolderSelected = rootSelect && !!rootSelect.value; // !! convertit en booléen (valeur non vide)
                        qualityProfileSelected = qualitySelect && !!qualitySelect.value;

                        allRequiredOptionsSelected = rootFolderSelected && qualityProfileSelected;
                    } else if (appType === 'radarr') {
                        const rootSelect = document.getElementById('radarrRootFolderSelectForAdd');
                        const qualitySelect = document.getElementById('radarrQualityProfileSelectForAdd');
                        const availabilitySelect = document.getElementById('radarrMinimumAvailabilitySelectForAdd'); // Le select pour la disponibilité

                        rootFolderSelected = rootSelect && !!rootSelect.value;
                        qualityProfileSelected = qualitySelect && !!qualitySelect.value;
                        // --- VÉRIFICATION AJOUTÉE POUR LA DISPONIBILITÉ RADARR ---
                        const availabilitySelected = availabilitySelect && !!availabilitySelect.value;

                        allRequiredOptionsSelected = rootFolderSelected && qualityProfileSelected && availabilitySelected;
                        // --- FIN VÉRIFICATION AJOUTÉE ---
                    }
                } else { // Média existant : l'ID du média suffit pour cette partie des conditions
                    allRequiredOptionsSelected = true;
                }
            }

            // Vérifier aussi qu'un fichier ou un magnet est fourni
            const magnetLinkInput = document.getElementById('torrentMagnetLink');
            const torrentFileInput = document.getElementById('torrentFileUpload');
            let magnetLink = "";
            let torrentFile = null;

            if (magnetLinkInput) magnetLink = magnetLinkInput.value.trim();
            if (torrentFileInput) torrentFile = torrentFileInput.files[0];

            const sourceProvided = !!(magnetLink || torrentFile);

            submitButton.disabled = !(allRequiredOptionsSelected && sourceProvided);

            console.log(
                `updateSubmitAddTorrentButtonState: \n` +
                `  - mediaId: ${mediaId} (un média est-il sélectionné ?)\n` +
                `  - isNew: ${isNew} (est-ce un nouveau média ?)\n` +
                `  - appType: ${appType} (Sonarr ou Radarr ?)\n` +
                `  - sourceProvided: ${sourceProvided} (fichier ou magnet ?)\n` +
                `  - allRequiredOptionsSelected (pour nouveau média): ${allRequiredOptionsSelected} (options d'ajout remplies ?)\n` +
                `  - SUBMIT_BTN_DISABLED: ${submitButton.disabled}`
            );
        }
        // --- FIN NOUVELLE FONCTION ---
    </script>
</body>
</html>