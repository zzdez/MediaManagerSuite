{% extends "layout.html" %}

{% block title %}MediaManagerSuite - Tableau de Bord{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <!-- Colonne des résultats (principale) -->
        <div class="col-md-10">
            <h1 class="mt-4">Tableau de Bord des Nouveautés</h1>
            <p>Cliquez sur le bouton pour rechercher les nouvelles publications depuis votre dernière visite.</p>
            <button id="refresh-btn" class="btn btn-primary mb-4">
                <i class="fas fa-sync-alt"></i> Rafraîchir les nouveautés
            </button>

            <div id="loading-spinner" style="display: none;" class="text-center">
                <div class="spinner-border text-primary" role="status">
                    <span class="sr-only">Chargement...</span>
                </div>
                <p>Recherche en cours...</p>
            </div>

            <div id="torrents-container">
                <!-- Les résultats seront injectés ici -->
            </div>
        </div>

        <!-- Colonne des filtres (latérale droite) -->
        <div class="col-md-2" style="position: sticky; top: 1rem; height: 95vh; overflow-y: auto;">
            <div class="filters-container p-3 rounded bg-dark">
                <h4><i class="fas fa-filter"></i> Filtres</h4>
                <button id="reset-filters-btn" class="btn btn-secondary btn-sm mb-3">Réinitialiser les filtres</button>

                <!-- Filtre par Titre -->
                <div class="mb-3">
                    <label for="filter-title" class="form-label">Titre</label>
                    <input type="text" class="form-control" id="filter-title" placeholder="Rechercher par titre...">
                </div>

                <!-- Filtre par Année -->
                <div class="mb-3">
                    <label for="filter-year" class="form-label">Année (plus récent que)</label>
                    <input type="number" class="form-control" id="filter-year" placeholder="Ex: 2023">
                </div>

                <!-- Filtre par Catégorie -->
                <div class="mb-3">
                    <label for="filter-category" class="form-label">Catégorie</label>
                    <select class="form-select" id="filter-category">
                        <option value="">Toutes</option>
                    </select>
                </div>

                <!-- Filtre par Statut -->
                <div class="mb-3">
                    <label for="filter-status" class="form-label">Statut</label>
                    <select class="form-select" id="filter-status">
                        <option value="">Tous</option>
                    </select>
                </div>

                <!-- Filtre par Indexeur -->
                <div class="mb-3">
                    <label for="filter-indexer" class="form-label">Indexeur</label>
                    <select class="form-select" id="filter-indexer">
                        <option value="">Tous</option>
                    </select>
                </div>

                <hr>

                <!-- Filtres par mots-clés (dynamiques) -->
                {% if keyword_filters %}
                <div id="keyword-filters-container" class="accordion">
                    {% for group_name, group_data in keyword_filters.items() %}
                    <div class="accordion-item bg-dark">
                        <h2 class="accordion-header" id="heading-{{ loop.index }}">
                            <button class="accordion-button bg-secondary text-white collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-{{ loop.index }}" aria-expanded="false" aria-controls="collapse-{{ loop.index }}">
                                {{ group_name }}
                            </button>
                        </h2>
                        <div id="collapse-{{ loop.index }}" class="accordion-collapse collapse" aria-labelledby="heading-{{ loop.index }}">
                            <div class="accordion-body">
                                <div class="btn-group-vertical w-100" role="group" aria-label="{{ group_name }}">
                                    {% if group_data.type == 'simple' %}
                                        {% for term in group_data.terms %}
                                        <div class="form-check">
                                            <input class="form-check-input keyword-filter-checkbox" type="checkbox" value="{{ term }}" id="filter-{{ group_name|lower|replace(' ', '-') }}-{{ term }}" data-group="{{ group_name }}">
                                            <label class="form-check-label" for="filter-{{ group_name|lower|replace(' ', '-') }}-{{ term }}">{{ term }}</label>
                                        </div>
                                        {% endfor %}
                                    {% elif group_data.type == 'alias' %}
                                        {# This is the new logic for languages from JSON config #}
                                        {% for display_name, aliases in group_data.terms.items() %}
                                        <div class="form-check">
                                            <input class="form-check-input keyword-filter-checkbox" type="checkbox" value="{{ display_name }}" id="filter-{{ group_name|lower }}-{{ display_name }}" data-group="{{ group_name }}" data-aliases="{{ aliases|join(',') }}">
                                            <label class="form-check-label" for="filter-{{ group_name|lower }}-{{ display_name }}">{{ display_name }}</label>
                                        </div>
                                        {% endfor %}
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                {% endif %}

            </div>
        </div>
    </div>
</div>

<!-- La modale de mapping est définie dans layout.html, nous n'avons pas besoin de la redéfinir ici -->

{% endblock %}

{% block scripts %}
{{ super() }}
<script>
$(document).ready(function() {

    // --- Global state ---
    let allTorrents = {{ torrents|tojson }};
    const keywordFiltersData = {{ keyword_filters|tojson if keyword_filters is defined else '{}' }};
    const KEYWORD_FILTER_STORAGE_KEY = 'dashboardKeywordFilterState';

    // --- DOM Elements ---
    const container = $('#torrents-container');
    const filterTitle = $('#filter-title');
    const filterYear = $('#filter-year');
    const filterCategory = $('#filter-category');
    const filterStatus = $('#filter-status');
    const filterIndexer = $('#filter-indexer');
    const keywordCheckboxes = $('.keyword-filter-checkbox');

    // --- Badge Generation Logic ---
    const statusMap = {
        'SONARR_MONITORED': { text: 'Sonarr (Surveillé)', class: 'bg-primary', group: 'Sonarr' },
        'SONARR_OBTAINED': { text: 'Sonarr (Obtenu)', class: 'bg-success', group: 'Sonarr' },
        'RADARR_MONITORED': { text: 'Radarr (Surveillé)', class: 'bg-warning text-dark', group: 'Radarr' },
        'RADARR_OBTAINED': { text: 'Radarr (Obtenu)', class: 'bg-warning text-dark', group: 'Radarr' },
        'PLEX_PRESENT': { text: 'Plex', class: 'bg-purple', group: 'Plex' },
        'ARCHIVED': { text: 'Archivé', class: 'bg-orange', group: 'Archivé' },
        'UNKNOWN_ID': { text: 'Inconnu', class: 'bg-secondary', group: 'Inconnu' },
        'NOT_MANAGED': { text: 'Non Géré', class: 'bg-secondary', group: 'Non Géré' }
    };

    function generateStatusBadges(statuses) {
        if (!statuses || statuses.length === 0) return '';
        let badgesHtml = '';
        statuses.forEach(status => {
            const badgeInfo = statusMap[status];
            if (badgeInfo) {
                badgesHtml += `<span class="badge ${badgeInfo.class} ms-1">${badgeInfo.text}</span>`;
            }
        });
        return badgesHtml;
    }

    // --- Core Rendering and Filtering Logic ---
    function renderTorrents(torrentsToRender) {
        container.empty();
        if (torrentsToRender.length === 0) {
            container.html('<div class="alert alert-info">Aucun torrent ne correspond à vos filtres.</div>');
            return;
        }

        // Sort: New items first, then by publish date
        torrentsToRender.sort((a, b) => {
            if (a.is_new && !b.is_new) return -1;
            if (!a.is_new && b.is_new) return 1;
            return new Date(b.publishDate) - new Date(a.publishDate);
        });

        torrentsToRender.forEach(torrent => {
            const sizeInGB = (torrent.size / (1024 * 1024 * 1024)).toFixed(2);
            const newBadge = torrent.is_new ? '<span class="badge bg-info ms-2">Nouveau</span>' : '';
            const statusBadges = generateStatusBadges(torrent.statuses);

            const yearMatch = torrent.title.match(/\b(19[89]\d|20\d{2})\b/);
            const year = yearMatch ? yearMatch[1] : null;

            const detailsButtonHtml = torrent.detailsUrl ? `<button class="btn btn-info btn-sm details-btn" data-url="${torrent.detailsUrl}">Détails</button>` : `<button class="btn btn-info btn-sm" disabled>Détails</button>`;
            const indexerBadge = torrent.indexer ? `<span class="badge bg-secondary me-1">${torrent.indexer}</span>` : '';

            let categoryBadgeClass = 'bg-dark';
            if (torrent.type === 'movie') categoryBadgeClass = 'bg-primary';
            else if (torrent.type === 'tv') categoryBadgeClass = 'bg-success';
            const categoryBadge = torrent.category ? `<span class="badge ${categoryBadgeClass}">${torrent.category}</span>` : '';

            const torrentCard = `
                <div class="card mb-3" id="torrent-card-${torrent.hash}">
                    <div class="card-body">
                        <h5 class="card-title">${torrent.title} ${newBadge}</h5>
                        <div>${statusBadges}</div>
                        <div class="mt-2">
                            ${indexerBadge}
                            ${categoryBadge}
                        </div>
                        <h6 class="card-subtitle mb-2 mt-2 text-muted">
                            <i class="fas fa-database"></i> ${sizeInGB} GB |
                            <i class="fas fa-arrow-up text-success"></i> ${torrent.seeders} |
                            <i class="fas fa-arrow-down text-danger"></i> ${torrent.leechers}
                        </h6>
                        ${detailsButtonHtml}
                        <button class="btn btn-primary btn-sm download-and-map-btn"
                                data-hash="${torrent.hash}" data-guid="${torrent.guid}" data-title="${torrent.title}"
                                data-download-link="${torrent.downloadUrl}" data-indexer-id="${torrent.indexerId}"
                                data-media-type="${torrent.type}" data-tmdb-id="${torrent.tmdbId || ''}"
                                data-tvdb-id="${torrent.tvdbId || ''}" data-year="${year || ''}">
                            <i class="fas fa-download"></i> & Mapper
                        </button>
                        <button class="btn btn-secondary btn-sm" data-action="ignore" data-hash="${torrent.hash}">
                            <i class="fas fa-eye-slash"></i> Ignorer
                        </button>
                    </div>
                </div>
            `;
            container.append(torrentCard);
        });
    }

    function applyFilters() {
        // --- Get standard filter values ---
        const titleFilter = filterTitle.val().toLowerCase();
        const yearFilter = parseInt(filterYear.val(), 10) || 0;
        const categoryFilter = filterCategory.val();
        const statusFilter = filterStatus.val();
        const indexerFilter = filterIndexer.val();

        // --- Get keyword filter values ---
        const activeKeywordFilters = {};
        keywordCheckboxes.filter(':checked').each(function() {
            const group = $(this).data('group');
            if (!activeKeywordFilters[group]) {
                activeKeywordFilters[group] = [];
            }
            // For alias types (like language), we store the aliases directly
            if (keywordFiltersData[group] && keywordFiltersData[group].type === 'alias') {
                const displayName = $(this).val(); // e.g., "Français"
                const aliases = keywordFiltersData[group].terms[displayName];
                if (aliases) {
                    activeKeywordFilters[group].push(...aliases);
                }
            } else {
                // For simple types, just add the value
                activeKeywordFilters[group].push($(this).val());
            }
        });

        const filteredTorrents = allTorrents.filter(torrent => {
            // Standard filters
            if (titleFilter && !torrent.title.toLowerCase().includes(titleFilter)) return false;

            const yearMatch = torrent.title.match(/\b(19\d{2}|20\d{2})\b/);
            const year = yearMatch ? parseInt(yearMatch[1], 10) : 0;
            if (yearFilter && (!year || year < yearFilter)) return false;

            if (categoryFilter && torrent.category !== categoryFilter) return false;
            if (indexerFilter && torrent.indexer !== indexerFilter) return false;

            if (statusFilter) {
                const hasStatus = torrent.statuses.some(s => statusMap[s] && statusMap[s].group === statusFilter);
                if (!hasStatus) return false;
            }

            // Keyword filters based on parsed data (AND between groups, OR within a group)
            const parsed = torrent.parsed_data || {};
            for (const group in activeKeywordFilters) {
                const terms = activeKeywordFilters[group];
                if (terms.length > 0) {
                    let match = false;
                    const lowerCaseTerms = terms.map(t => t.toLowerCase());

                    if (group === 'Langue' && parsed.language) {
                        match = lowerCaseTerms.some(term => parsed.language.toLowerCase().includes(term));
                    } else if (group === 'Qualité' && parsed.quality) {
                        match = lowerCaseTerms.includes(parsed.quality.toLowerCase());
                    } else if (group === 'Codec' && parsed.codec) {
                        match = lowerCaseTerms.includes(parsed.codec.toLowerCase());
                    } else if (group === 'Source' && parsed.source) {
                        match = lowerCaseTerms.includes(parsed.source.toLowerCase());
                    } else if (group === 'Release Group' && parsed.release_group) {
                        match = lowerCaseTerms.includes(parsed.release_group.toLowerCase());
                    }

                    if (!match) return false; // Must match at least one term in this group
                }
            }

            return true;
        });

        renderTorrents(filteredTorrents);
    }

    function populateFilters() {
        const categories = new Set();
        const statuses = new Set();
        const indexers = new Set();

        allTorrents.forEach(torrent => {
            if (torrent.category) categories.add(torrent.category);
            if (torrent.indexer) indexers.add(torrent.indexer);
            torrent.statuses.forEach(s => {
                const statusInfo = statusMap[s];
                if (statusInfo) statuses.add(statusInfo.group);
            });
        });

        const populateSelect = (select, items) => {
            const currentVal = select.val();
            select.html('<option value="">Tous</option>');
            [...items].sort().forEach(item => select.append(new Option(item, item)));
            select.val(currentVal);
        };

        populateSelect(filterCategory, categories);
        populateSelect(filterStatus, statuses);
        populateSelect(filterIndexer, indexers);
    }

    // --- Keyword Filter Persistence ---
    function saveKeywordFilterState() {
        const state = {};
        keywordCheckboxes.each(function() {
            state[this.id] = this.checked;
        });
        localStorage.setItem(KEYWORD_FILTER_STORAGE_KEY, JSON.stringify(state));
    }

    function loadKeywordFilterState() {
        const savedState = localStorage.getItem(KEYWORD_FILTER_STORAGE_KEY);
        if (savedState) {
            const state = JSON.parse(savedState);
            keywordCheckboxes.each(function() {
                this.checked = state[this.id] !== false; // Default to true if not found
            });
        } else {
            // Default state: all checked
            keywordCheckboxes.prop('checked', true);
        }
    }

    // --- Event Handlers ---
    $('#filter-title, #filter-year').on('input', applyFilters);
    $('#filter-category, #filter-status, #filter-indexer').on('change', applyFilters);
    keywordCheckboxes.on('change', function() {
        saveKeywordFilterState();
        applyFilters();
    });

    $('#reset-filters-btn').on('click', function() {
        filterTitle.val('');
        filterYear.val('');
        filterCategory.val('');
        filterStatus.val('');
        filterIndexer.val('');
        keywordCheckboxes.prop('checked', true); // Reset checkboxes to all checked
        saveKeywordFilterState();
        applyFilters();
    });

    // --- Initial Load ---
    populateFilters();
    loadKeywordFilterState();
    applyFilters();

    // --- Refresh Button Logic ---
    $('#refresh-btn').on('click', function() {
        const button = $(this);
        const spinner = $('#loading-spinner');
        const container = $('#torrents-container');

        button.prop('disabled', true);
        spinner.show();
        container.empty();

        window.currentMediaContext = null;

        $.ajax({
            url: "{{ url_for('dashboard_bp.refresh_torrents') }}",
            type: 'GET',
            success: function(response) {
                if (response.status === 'success') {
                    renderTorrents(response.torrents);
                } else {
                    container.html(`<div class="alert alert-danger">Erreur: ${response.message || 'Une erreur est survenue.'}</div>`);
                }
            },
            error: function() {
                container.html('<div class="alert alert-danger">Erreur de communication avec le serveur.</div>');
            },
            complete: function() {
                button.prop('disabled', false);
                spinner.hide();
            }
        });
    });

    // --- Event delegation for action buttons ---
    $('#torrents-container').on('click', 'button[data-action="ignore"]', function() {
        const torrentId = $(this).data('hash'); // 'hash' data attribute holds the unique ID (hash or guid)
        const cardElement = $(this).closest('.card');

        $.ajax({
            url: "/dashboard/api/ignore",
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ id: torrentId }),
            success: function(response) {
                if (response.status === 'success') {
                    cardElement.fadeOut(500, function() { $(this).remove(); });
                } else {
                    alert('Erreur lors de l_ignorance du torrent: ' + response.message);
                }
            },
            error: function() {
                alert('Erreur de communication avec le serveur.');
            }
        });
    });

    // --- Intelligent Details Button Handler ---
    $('#torrents-container').on('click', '.details-btn', function() {
        const url = $(this).data('url');
        if (!url) return;

        // --- Calculate window position for centering ---
        const windowWidth = 1200;
        const windowHeight = 800;
        const left = (screen.width / 2) - (windowWidth / 2);
        const top = (screen.height / 2) - (windowHeight / 2);
        const windowFeatures = `width=${windowWidth},height=${windowHeight},top=${top},left=${left},resizable=yes,scrollbars=yes`;

        // Special handling for YGG API URLs via our backend proxy
        if (url.includes('yggapi.eu')) {
            const proxyUrl = `/dashboard/api/proxy?url=${encodeURIComponent(url)}`;
            fetch(proxyUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Proxy network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.link) {
                        window.open(data.link, 'MMS_Details_Window', windowFeatures);
                    } else {
                        // Fallback to opening the original URL if parsing fails
                        window.open(url, 'MMS_Details_Window', windowFeatures);
                    }
                })
                .catch(error => {
                    console.error('Failed to fetch YGG details via proxy:', error);
                    // Fallback to opening the original URL on error
                    window.open(url, 'MMS_Details_Window', windowFeatures);
                });
        } else {
            // Standard behavior for all other indexers
            window.open(url, 'MMS_Details_Window', windowFeatures);
        }
    });

});
</script>
{% endblock %}
